<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="AngryTester" type="application/atom+xml" />






<meta name="description" content="起点不论好坏，终点始终美好！">
<meta property="og:type" content="website">
<meta property="og:title" content="AngryTester">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="AngryTester">
<meta property="og:description" content="起点不论好坏，终点始终美好！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AngryTester">
<meta name="twitter:description" content="起点不论好坏，终点始终美好！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>AngryTester</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AngryTester</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">起点不论好坏，终点始终美好！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/基于Jenkins构建持续交付管道（五）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/09/基于Jenkins构建持续交付管道（五）/" itemprop="url">基于Jenkins构建持续交付管道（五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T17:06:05+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章中介绍了目前基于Jenkins的Pipeline As Code，解决了之前基于Build Pipeline的一系列问题，本章中我们将介绍引入docker来优化我们的持续交付管道。</p>
<h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>简单来说，Docker是区别于传统虚拟化的另外一种虚拟方式，更轻便。</p>
<p>具体可以参考：<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html</a></p>
<h2 id="Docker可以解决什么问题"><a href="#Docker可以解决什么问题" class="headerlink" title="Docker可以解决什么问题"></a>Docker可以解决什么问题</h2><p>之前有提到过Jenkins完成构建任务主要是通过插件，插件则依赖持续集成服务器上的工具。比如如果我需要完成一个Maven工程的编译打包，首先得需要持续集成服务器上得有Maven工具，才能在管道中调用服务器里的Maven工具完成打包。这样带来的直接问题就是：不同构建任务如果需要不同构建工具，则需要在服务器上配置各种构建工具，这对于持续集成服务器的维护工作是个挑战。</p>
<p>除了持续集成服务器的维护工作，其实Docker技术的初衷是解决环境一致性的问题。众所周知，生产环境和测试环境或者开发环境的一致性，一直是交付团队苦恼的问题，特别在一些底层环境非常复杂的系统中尤为明显。Docker可以实现将应用包和底层依赖环境打包成一个完成镜像，这个镜像在各种环境下启动的表现完全一致，前提是各种环境需要支持Docker。这里所说的依赖包括JDK、中间件等等。</p>
<h2 id="Docker在Jenkins持续交付管道中的应用"><a href="#Docker在Jenkins持续交付管道中的应用" class="headerlink" title="Docker在Jenkins持续交付管道中的应用"></a>Docker在Jenkins持续交付管道中的应用</h2><p>管道代码片段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker.image(&apos;registry.cae.com/angrytester/maven:3-jdk-7&apos;).inside(&apos;-v /root/.m2/repository:/root/.m2/repository)&#123;</div><div class="line">	stage &apos;Build&apos;</div><div class="line">	sh &quot;mvn clean install -Dmaven.test.skip=true&quot;	  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码实现了一个stage，名为Build。以下是具体执行逻辑：</p>
<blockquote>
<p>首先从镜像库中根据镜像tag=hub.com/angrytester/maven:3-jdk-7拉一个镜像到持续集成服务器并启动一个容器，将容器里的root/.m2/repository目录挂载到持续集成服务器的root/.m2/repository目录。前面为持续集成服务器的路径，后面为容器内的路径。</p>
<p>然后在容器内执行shell命令： mvn clean install -Dmaven.test.skip=true</p>
<p>从以上就可以看出来，不需要构建服务器上有Maven工具，如果需要执行Maven构建，只需要拉一个Maven镜像并起一个容器，然后在容器内就可以直接执行Maven的相关构建命令了。</p>
</blockquote>
<h2 id="Docker-in-Docker"><a href="#Docker-in-Docker" class="headerlink" title="Docker in Docker"></a>Docker in Docker</h2><p>在持续交付管道中引入Docker之后，由于后续涉及打镜像，所以肯定需要用到Docker的相关服务，即需要在Docker容器里再起Docker服务，这就涉及到Docker in Docker的知识了。</p>
<p>官方其实是支持Docker in Docker的，具体可参考：<a href="https://hub.docker.com/_/docker/" target="_blank" rel="external">https://hub.docker.com/_/docker/</a></p>
<p>即需要先起一个Docker容器，然后再起另外一个容器link到这个容器，然后在新起的这个容器里就可以执行Docker相关命令了。</p>
<p>下面的脚本示例片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker.image(&apos;docker:1.13-dind&apos;).run(&quot;--privileged --name docker-dind&quot;)</div><div class="line">docker.image(&apos;docker:1.13&apos;).withRun(&quot;--link docker-dind:docker&quot;)&#123;</div><div class="line">      sh &quot;docker images&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>需要注意，在启动dind容器时，必须使用特权即privileged模式。</p>
<h2 id="引入Docker之后持续交付管道的一些变化"><a href="#引入Docker之后持续交付管道的一些变化" class="headerlink" title="引入Docker之后持续交付管道的一些变化"></a>引入Docker之后持续交付管道的一些变化</h2><ul>
<li><p>构建环境自定制而非依赖构建服务器</p>
</li>
<li><p>构建产物为镜像而非应用包</p>
</li>
<li><p>应用通过容器启动而非应用服务器启动</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/基于Jenkins构建持续交付管道（四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/基于Jenkins构建持续交付管道（四）/" itemprop="url">基于Jenkins构建持续交付管道（四）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T08:24:44+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章介绍了如何基于build pipeline plugin插件搭建Jenkins的持续交付管道，但是实际上是通过另外新建一个视图来将原本没有关系的Job串联在一起，构成“管道”视图。这种方式的好处在于实现简单，不需要变更使用习惯。
　　</p>
<p>但是随着持续交付管道应用的深入，渐渐会发现这种方式的种种弊端：</p>
<ul>
<li><p>与“管道流”的初衷违背。由于各个交付节点实际上是各自分离的独立Job，所以每一个Job会在都是在自己的独立工作空间进行构建任务。这与“管道流”的初衷-上一节点的合格交付物流入下一节点-是违背的，因为各个Job的交付物其实是没有直接关联的；</p>
</li>
<li><p>Job维护工作量大。由于每一个交付管道的节点数众多，意味着每一条交付管道需要你维护多个Job，然后再将各个Job串联。因此，你可能需要花费大量时间来维护多个Job配置；</p>
</li>
<li><p>交付反馈流程可能存在冗余。由于各个Job都有自己独立的工作空间，各个工作空间是无法直接交互的。为了尽早反馈，我们希望将反馈节点尽量分割开，比如单元测试和静态扫描我们会分离成两个Job，但是静态扫描实际会依赖单元测试的产物（主要是覆盖率jacoco文件），所以导致单元测试可能会在单元测试和静态扫描环节重复执行，同样的情况还存在于编译打包和部署环节。</p>
</li>
</ul>
<p>　　<br>因此，我们适时考虑Jenkins官方推荐的Pipeline As Code。</p>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Jenkins的Pipeline As Code基于pipeline插件。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/1.png" alt=""></p>
<p>在安装完插件之后，在新建Job的时候就可以选择pipeline类型了。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/2.png" alt=""></p>
<p>新建一个pipeline类型Job，看一下Job的配置，会发现和之前介绍的常规Job有所区别。除了触发策略，另一部分就是pipeline的脚本，从这里也能看出来相比传统Job，配置会更简单。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/3.png" alt=""></p>
<p>pipeline的核心就是管道脚本。那么脚本如何设计呢？</p>
<p>Jenkins提供了几个pipeline脚本的例子，可以选择GitHub+Maven的例子。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/4.png" alt=""></p>
<p>下面以上面的例子讲解一下脚本的写法。</p>
<ul>
<li><p>第一行node：代表后面跟的大括号里的构建脚本将在哪个节点上运行，如果是空，则默认在master节点，否则可以写做node(“slave”)，这里的slave是你的节点名称。</p>
</li>
<li><p>def  mvnHome：定义一个变量mvnHome，因为Jenkins的Pipeline脚本是基于Groovy语言的，所以里面可以直接使用Groovy的一些语言特性，包括这里的定义变量以及后面的逻辑语句。</p>
</li>
<li><p>stage(‘Preparation’)：定义一个交付节点，代表后面跟的大括号里的脚本统一定义为一个交付节点，节点名称为“Preparation”，有点类似之前方案中的持续交付管道的Job名称。</p>
</li>
<li><p>git ‘<a href="https://github.com/jglick/simple-maven-project-with-tests.git&#39;:获取指定git版本库的代码。这种格式是如何定义的呢？可以通过下方的Pipeline" target="_blank" rel="external">https://github.com/jglick/simple-maven-project-with-tests.git&#39;:获取指定git版本库的代码。这种格式是如何定义的呢？可以通过下方的Pipeline</a> Syntax链接跳转到新页面进行调试。</p>
</li>
</ul>
<p>例如如果希望获取某个git库的代码，选择git后填写好相应信息，点击Generate Pipeline Script，就会生成对应代码：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/git.jpg" alt=""></p>
<p>上面的例子不用输入git用户名密码，是因为配置了git的SSH Key。可参考：<a href="http://blog.csdn.net/fenglailea/article/details/39317513。" target="_blank" rel="external">http://blog.csdn.net/fenglailea/article/details/39317513。</a></p>
<ul>
<li>mvnHome = tool ‘M3’：变量赋值。M3是哪里配置的呢？在装好Maven插件之后，系统管理里增加Maven时的命令。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/maven.jpg" alt=""> </p>
<p>“M3”就应该替换成“apache-maven-3.3.9”。</p>
<ul>
<li><p>stage(‘Build’)：定义另一个交付节点，代表后面跟的大括号里的脚本统一定义为一个交付节点，节点名称为“Build”。</p>
</li>
<li><p>if (isUnix())：判断服务器是否为Unix系列，与后面的大括号共同形成逻辑判断语句。</p>
</li>
<li><p>sh “‘${mvnHome}/bin/mvn’ -Dmaven.test.failure.ignore clean package”：如果服务器为Unix系列，则执行这段bash，${mvnHome}为前面定义的变量mvnHome的值。</p>
</li>
<li><p>bat(/“${mvnHome}\bin\mvn” -Dmaven.test.failure.ignore clean package/)：如果服务器不为Unix（即为Windows系列），则执行这段bat。</p>
</li>
<li><p>stage(‘Results’)：定义另一个交付节点，代表后面跟的大括号里的脚本统一定义为一个交付节点，节点名称为“’Results’”。</p>
</li>
<li><p>junit ‘<em>*/target/surefire-reports/TEST-</em>.xml’：发布junit测试结果，后面为junit执行产生的xml文件地址。</p>
</li>
<li><p>archive ‘target/*.jar’：存档文件，后面内容为存档文件路径。</p>
</li>
</ul>
<p>除了示例脚本，Jenkins还提供了编写脚本的帮助工具，通过脚本配置框下面的Pipeline Syntax或者Job首页的Pipeline Syntax均可进入。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/6.png" alt=""></p>
<p>例如，我需要从一个Git库中检出代码，可以选择下拉选择Git，然后输入Git库地址，点击生成脚本按钮，就会在下面生成对应的脚本，这段脚本就可以加到你们的pipeline中了。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/7.png" alt=""></p>
<p>除了在线编写脚本，也可以通过版本库直接读取管道脚本：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E5%9B%9B%EF%BC%89/8.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从上面的示例脚本可以看出来，Build节点的产物如Jar包在最后的Result节点就可以直接存档了。这与管道流的概念不谋而合，下一个节点的产物应该来自于上一个节点。</p>
<ul>
<li><p>以上示例脚本相当于完成了3个Job，所以维护工作相比之前的方式大大减少了。</p>
</li>
<li><p>由于整个管道都是在同一个工作空间，所以各个交付节点的产物都可以复用。之前存在的单元测试需要执行两遍的冗余就不存在了。</p>
</li>
<li><p>减少冗余之后管道执行时间自然有所缩短。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/Jenkins环境部署结束自动验证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/Jenkins环境部署结束自动验证/" itemprop="url">Jenkins环境部署结束自动验证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T10:49:49+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>前面有讲到通过Jenkins完成环境部署的步骤，在实际使用过程中遇到一个问题，因为在war包传输结束后执行完shell，部分容器可能启动时间需要较长时间，可能造成shell执行结束，直接触发了构建成功的邮件，测试人员收到邮件之后却发现环境还没有起来，对我们造成一定困扰。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在shell最后加以下这段代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">STATUS_CODE=0</div><div class="line">echo $STATUS_CODE</div><div class="line">while [[ $STATUS_CODE != 200 ]]</div><div class="line">do</div><div class="line">    STATUS_CODE=`curl -o /dev/null -s -w %&#123;http_code&#125; http://localhost:8080/test.html`</div><div class="line">done</div></pre></td></tr></table></figure>
<p>其中<a href="http://localhost:8080/test.html即为你需要验证的测试环境地址，这样一直到环境访问返回200，否则shell会一直执行等待。" target="_blank" rel="external">http://localhost:8080/test.html即为你需要验证的测试环境地址，这样一直到环境访问返回200，否则shell会一直执行等待。</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/Jenkins通过正则获取指定日志并邮件发送/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/Jenkins通过正则获取指定日志并邮件发送/" itemprop="url">Jenkins通过正则获取指定日志并邮件发送</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T10:31:39+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Jenkins没有数据库，因此构建产出的内容都是放在文件中，如果要获取构建日志中的指定内容会非常麻烦。例如有一些用于造测试数据的自动化工具，需要从构建日志中获取到指定的测试数据，则需要借助正则解析构建日志。</p>
<h2 id="Email-ext-plugin"><a href="#Email-ext-plugin" class="headerlink" title="Email-ext plugin"></a>Email-ext plugin</h2><p>Email-ext plugin插件提供了通过正则解析构建日志，提取指定构建日志内容的功能。$BUILD_LOG_MULTILINE_REGEX</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>在邮件content中配置如下内容：</p>
<p>${BUILD_LOG_MULTILINE_REGEX,regex=”测试数据：.*”,maxMatches=0,showTruncatedLines=false,escapeHtml=false,matchedSegmentHtmlStyle=”color:blue”}</p>
<p>则可以获取到以“测试数据开头”的内容，并通过邮件发送。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/基于Jenkins构建持续交付管道（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/基于Jenkins构建持续交付管道（三）/" itemprop="url">基于Jenkins构建持续交付管道（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T08:57:41+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章中已经介绍了如何基于Jenkins配置一个独立的Job，即完成了交付流程中单个节点的实现，持续交付管道需要将交付流程中的各个节点串起来，再加上适当的反馈。本章将介绍如何将各个独立Job进行串联。</p>
<h2 id="各个交付节点的实现"><a href="#各个交付节点的实现" class="headerlink" title="各个交付节点的实现"></a>各个交付节点的实现</h2><p>结合上一章的内容，交付流程中的各个节点其实就对应到一个一个的Job。以典型的Java项目为例，如果使用Maven进行构建，可能涉及的节点可能有：编译打包、单元测试、静态扫描、测试部署、功能测试等。分别对应的Maven命令如下：</p>
<ul>
<li><p>编译打包(跳过单元测试)：mvn clean install -Dmaven.test.skip=true</p>
</li>
<li><p>单元测试：mvn clean test</p>
</li>
<li><p>静态扫描：mvn sonar:sonar</p>
</li>
</ul>
<h3 id="测试环境部署"><a href="#测试环境部署" class="headerlink" title="测试环境部署"></a>测试环境部署</h3><p>测试环境部署与其他交付节点有所不同，因此涉及与测试服务器的交互，所以测试环境部署任务需要分成两步。第一步是打包，第二步才是部署。但是庆幸的是Jenkins提供了相关插件，让你可以在一个Job中完成整个部署操作。</p>
<p>打包部分可以参考上面的内容，即mvn clean install即可完成。但是之后对测试服务器的操作得依赖另一个插件：publish over ssh。</p>
<p>在插件安装完成之后，需要在Jenkins中对测试服务器进行配置，然后在Job中才可以选择使用。具体操作是：<code>系统管理&gt;系统设置&gt;Publish over SSH</code>。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/1.png" alt=""></p>
<p>点击“增加”按钮，参考以下内容输入：</p>
<ul>
<li><p>Name：定义服务器名称，可自定义</p>
</li>
<li><p>Hostname:服务器IP</p>
</li>
<li><p>Username:登录用户名</p>
</li>
<li><p>Remote Directory：默认SSH进入的路径</p>
</li>
</ul>
<p>点击高级，勾选“Use password authentication, or use a different key”，</p>
<p>-Passphrase / Password：登录密码</p>
<p>点击Test Configuration可以测试配置，如果返回“连接成功”，则代表配置正确。</p>
<p>再进入Job设置，在Post Step下选择“Send file or execute commands over SSH”。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/2.png" alt=""></p>
<p>参考以下内容输入：</p>
<ul>
<li><p>Name：下拉选择系统设置中配置的服务器</p>
</li>
<li><p>Source files：需要传输的文件，相对路径。如工作空间下有一个文件夹aa，需要传输aa下面的bb.war，则这里需要输入aa/bb.war</p>
</li>
<li><p>Remove prefix：去掉上一条内容前缀，即如果这里输入aa/，这内容变为bb.war。</p>
</li>
<li><p>Remote directory：文件发送的远程路径，与系统设置中的远程路径组合成完整路径。例如这里输入opt/app，加上系统设置中的/，则完整远程路径为/opt/app</p>
</li>
<li><p>Exec command：需要执行的命令。以上已经完成了文件的传输，一般是war包，即需要部署的文件已经发送至测试服务器了。还需要在测试服务器上执行一段shell，例如停止应用服务器，传输war包等。就可以在这里配置。</p>
</li>
</ul>
<p>通过以上配置，就可以完成测试环境的部署了。</p>
<h2 id="各个交付节点的串联"><a href="#各个交付节点的串联" class="headerlink" title="各个交付节点的串联"></a>各个交付节点的串联</h2><p>Jenkins的交付节点串联依赖另一个插件-build pipeline plugin。在安装完这个插件之后，进入Job设置，在“增加构建后操作”下选择“Trigger parameterized build on other projects”：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/3.png" alt=""></p>
<ul>
<li><p>Projects to build:即当前job构建结束之后要运行的Job名称。</p>
</li>
<li><p>Trigger when build is：当前Job构建状态为XX时才触发。</p>
</li>
<li><p>Trigger build without parameters：不需要指定参数构建，如果不传参数，这个必须勾选上，否则串联会有问题。</p>
</li>
<li><p>Add Parameters：可以指定参数。这里重点需要说明的是SVN Revision参数，如果你需要将前一个Job的SVN版本号传给下一个Job，就可以把这个参数加上。重点解决的是前后如果对同一份代码进行编译和单元测试，可能造成前后版本不一致（编译过程中有人提交）。</p>
</li>
</ul>
<p>这样串联之后，在当前Job执行完之后就会自动触发下一个Job执行了。</p>
<h2 id="创建管道视图"><a href="#创建管道视图" class="headerlink" title="创建管道视图"></a>创建管道视图</h2><p>上面的步骤实际已经将各个Job串联成一条管道了，但是缺乏一个统一视图。可以通过添加build pipeline视图来创建一个管道视图。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/4.png" alt=""></p>
<p>重点需要配置的是初始Job。其他配置可以根据需要选择。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/5.png" alt=""></p>
<p>配置之后，就能看到一个管道的视图了，点击Run，就会自动运行整条管道了。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%89%EF%BC%89/6.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上是管道的主要实现，在实际应用过程中，可能还有一些细节需要优化，例如反馈机制（邮件通知），触发规则等等。可根据各个项目的不同需求自行定制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/27/基于Jenkins构建持续交付管道（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/基于Jenkins构建持续交付管道（二）/" itemprop="url">基于Jenkins构建持续交付管道（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-27T16:16:33+08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系统旨在从零基础开始讲解如何基于Jenkins搭建持续交付管道，因此本系列前面几篇会比较基础。本章结合实例讲解Jenkins的基础用法。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>上一章中提到了在第一次启动过程中选择插件安装，那之后的使用过程中如果需要用到其他插件呢？</p>
<p>具体操作是：进入<code>系统管理&gt;管理插件</code>，点击“可选插件标签”，可看到所有可用插件，可通过右上角输入框进行过滤：</p>
<p>例如需要安装maven插件，可在输入框中输入”maven”,可看到可用插件被过滤到只剩几个。选择Maven Integration plugin，点击直接安装。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt=""></p>
<blockquote>
<p>部分插件可能需要重启服务才能生效。</p>
</blockquote>
<h2 id="工具设置"><a href="#工具设置" class="headerlink" title="工具设置"></a>工具设置</h2><p>之前第一章中已经说到，Jenkins主要依赖服务器上的插件完成构建任务，所以在安装完插件之后，还需要在Jenkins中进行设置，将服务器上的相关工具做关联。</p>
<p>具体操作是：进入<code>系统管理&gt;Global Tool Configuration</code>，可看到下图：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" alt=""></p>
<h3 id="新增JDK"><a href="#新增JDK" class="headerlink" title="新增JDK"></a>新增JDK</h3><p>点击“新增JDK”按钮，取消“自动安装”选项，输入别名（可自定义），JAVA_HOME输入服务器上的JDK地址。如图：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt=""></p>
<p>可点击“新增JDK”增加更多其他版本JDK（例如一个服务器上存在多个JDK的情况）。</p>
<h3 id="新增MAVEN"><a href="#新增MAVEN" class="headerlink" title="新增MAVEN"></a>新增MAVEN</h3><p>同新增JDK，如图：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt=""></p>
<blockquote>
<p>如果安装了其他插件如Git，也参考以上步骤进行设置。</p>
</blockquote>
<h2 id="邮件设置"><a href="#邮件设置" class="headerlink" title="邮件设置"></a>邮件设置</h2><p>在Job构建结束后可能需要通过邮件通知到构建负责人结果，所以需要进行邮件设置。Jenkins提供了邮件服务，但需要进行邮件服务器的相关配置。邮件服务依赖邮件相关插件，推荐Email Extension Plugin。安装完插件后，还需要进行相关配置。</p>
<p>具体操作是：进入<code>系统管理&gt;系统设置</code>，可看到下图：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt=""></p>
<p>点击高级，勾选“Use SMTP Authentication”，配置SMTP服务器以及用户名密码，即使用Jenkins的邮件服务了。</p>
<blockquote>
<p>注意，配置完邮件服务器相关信息后，需要配置系统管理员邮件地址，格式为：address not configured yet <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#110;&#x6f;&#x62;&#x6f;&#100;&#x79;&#64;&#110;&#x6f;&#119;&#x68;&#101;&#x72;&#101;">&#110;&#x6f;&#x62;&#x6f;&#100;&#x79;&#64;&#110;&#x6f;&#119;&#x68;&#101;&#x72;&#101;</a>，例如Jenkins <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#49;&#x32;&#x33;&#52;&#x35;&#54;&#55;&#56;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#49;&#x32;&#x33;&#52;&#x35;&#54;&#55;&#56;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a>,其中12345678@qq.com必须为之前配置的邮件服务器对应的邮箱地址。</p>
</blockquote>
<h2 id="新建一个maven项目"><a href="#新建一个maven项目" class="headerlink" title="新建一个maven项目"></a>新建一个maven项目</h2><p>在安装了MAVEN插件之后，新建Job选项就会出现新建一个Maven项目。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" alt=""></p>
<blockquote>
<p>注意，在Maven项目的Goals and options中，不需要输入mvn，例如执行单元测试，只需要输入clean test。</p>
</blockquote>
<h2 id="配置邮件通知"><a href="#配置邮件通知" class="headerlink" title="配置邮件通知"></a>配置邮件通知</h2><p>在安装了相关插件并进行了相关配置之后，可以在Job中使用邮件通知。</p>
<p>具体操作是在<code>Job设置&gt;构建后操作</code>，选择“Editable Email Notification”。</p>
<ul>
<li><p>Project Recipient List：如果不修改，默认是读取系统设置中的收件人列表，也可修改为aa@xx.com,bb@xx.com</p>
</li>
<li><p>Default Subject与Default Content：同上。</p>
</li>
<li><p>Attachments：如果需要在邮件中附上附件，可在这个选项中配置。默认取相对路径。例如在工作空间子目录aa下有一个1.txt，则这里配置aa/1.txt</p>
</li>
<li><p>advanced setting-Triggers：设置触发条件和发送对象。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/基于Jenkins构建持续交付管道（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/24/基于Jenkins构建持续交付管道（一）/" itemprop="url">基于Jenkins构建持续交付管道（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-24T08:57:27+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续交付流程的持续指的是不断产出能够工作的成果。与敏捷思想一致，过程中通过不断对产出成果进行验证，避免与最终客户实际需求有过大偏差。</p>
<p>持续交付管道是持续交付的实践之一，持续交付管道的核心包括自动化、管道化和持续化。自动化的意义在于提升效率，管道化的意义在于节约流程控制所需要的人工成本，持续化的目的不断产出成果，加强过程结果监控。</p>
<p>以常见的Java项目为例，从代码检入到最后代码投产到生产环境，大致会包含单元测试，静态扫描，自动部署，功能测试，性能测试，安全测试、自动投产等一系列检查步骤。这里将自动部署和自动投产也列为检查步骤之一，是因为我认为自动部署和自动投产都不应该仅以执行完部署或投产的脚本就算成功，而是以部署完或投产之后环境符合预期，才能作为这两个步骤的成功条件。</p>
<p>持续交付管道的实现就是将各个检查步骤尽可能自动化，并串成一条线，通过管道中的自动反馈，能够快速直接地反馈当前工作成果的实际情况，比如是已经测试通过了还是连单元测试都没通过。</p>
<p>基于Jenkins的持续交付管道实现方式有两种，其中第一种相对好理解也好实现，但是非官方，第二种是官方推荐的管道实现方式。</p>
<h2 id="关于Jenkins"><a href="#关于Jenkins" class="headerlink" title="关于Jenkins"></a>关于Jenkins</h2><p>关于Jenkins，各种资料网上已经非常齐全了，这里仅从我个人理解谈谈Jenkins。</p>
<p>Jenkins自身并没有构建的功能，Jenkins更像是一个调度器，通过调度其他工具，来完成构建任务。</p>
<p>Jenkins调度其他工具主要是依赖自身的插件系统，可以理解为Jenkins系统仅是为各种工具提供了一个图形界面，用于配置基于各个工具的构建任务。所以业界对Jenkins的评价中有一条比较负面的就是说在Jenkins的使用过程中有可能陷入“插件地狱”，主要因为Jenkins的各种插件之间的依赖关系非常复杂，使用A插件可能需要B插件已经安装，并且可能要求B插件的版本必须大于指定版本，必须依赖Jenkins的在线安装，否则手工安装插件的工作量特别大。</p>
<h3 id="Jenkins的启动"><a href="#Jenkins的启动" class="headerlink" title="Jenkins的启动"></a>Jenkins的启动</h3><p>Jenkins的启动非常简单，从官方下载的Jenkins镜像是一个War包，所以可以用业界常见的容器比如Tomcat启动，同时,Jenkins内置了一个Jetty，所以也可以不依赖容器启动。</p>
<blockquote>
<p>利用内置Jetty容器启动</p>
<p><code>java -jar jenkins.war</code></p>
</blockquote>
<p>所以，只需要有JDK环境，就可以启动一个Jenkins服务。</p>
<blockquote>
<p>同时可以在启动时候指定一些参数，例如默认的Jenkins启动是在8080端口，如果想另外指定启动端口，可以通过命令参数httpPort。</p>
<p><code>java -jar jenkins.war --httpPort=8081</code></p>
</blockquote>
<p>则Jenkins就启动在8081端口了，本地可通过localhost:8081就可以访问到Jenkins服务了。</p>
<h3 id="Jenkins的第一次配置"><a href="#Jenkins的第一次配置" class="headerlink" title="Jenkins的第一次配置"></a>Jenkins的第一次配置</h3><p>Jenkins的第一次启动需要有一些默认配置，例如管理员账号，代理等。</p>
<p>下图是访问Jenkins第一次启动的页面：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt=""></p>
<p>需要输入默认管理员密码，这密码从哪里获取呢？</p>
<blockquote>
<p>可以从提示的路径，如上图所示，C:\Users\XX.jenkins\secrets\initialAdminPassword，XX为你当前用户名。</p>
<p>也可以从启动日志中获取，如下图所示：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt=""></p>
<p>输入密码之后下一步，到达代理设置页面，如果你的网络有代理，可以点击代理设置配置代理，否则也可以直接点击直接跳过插件安装。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%80%EF%BC%89/4.png" alt=""></p>
<p>在配置完代理之后下一步，会进入插件安装选择页面，分别有两个选项，第一个选项是安装推荐插件，第二个选项是自己选择安装，建议选择第二个选项。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%80%EF%BC%89/6.png" alt=""></p>
<p>这里介绍几个常用的插件，如图：</p>
<ul>
<li><p>Subversion Plug-in：SVN插件，需要有这个插件才能从SVN中检出代码。</p>
</li>
<li><p>Pipeline:官方推荐的管道插件，也是咱们的持续交付管道要用到的。</p>
</li>
<li><p>Maven Integration plugin：MAVEN插件，需要有这个插件才能新建MAVEN类型的Job。</p>
</li>
<li><p>Git plugin：Git插件，需要有这个插件才能从Git中检出代码。</p>
</li>
</ul>
<p>可以按照个人需求选择安装插件，待安装完成后，进入最后一步设置，设置管理员用户密码。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%80%EF%BC%89/8.png" alt=""></p>
<p>设置完成之后正式进入Jenkins首页。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/%E5%9F%BA%E4%BA%8EJenkins%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%AE%A1%E9%81%93%EF%BC%88%E4%B8%80%EF%BC%89/9.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/20/修改tomcat镜像并重新上传/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/20/修改tomcat镜像并重新上传/" itemprop="url">修改tomcat镜像并重新上传</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-20T17:58:14+08:00">
                2017-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>最近遇到两个问题，需要对已有的镜像进行修改并重新上传。</p>
<h3 id="修改tomcat默认设置"><a href="#修改tomcat默认设置" class="headerlink" title="修改tomcat默认设置"></a>修改tomcat默认设置</h3><p>有个项目需要用到ojdbc的jar包，需要放到tomcat的lib里，默认的tomcat没有这个jar包，所以需要手动上传至lib然后重新打镜像。</p>
<h3 id="修改应用参数"><a href="#修改应用参数" class="headerlink" title="修改应用参数"></a>修改应用参数</h3><p>第二个场景略奇葩，有个项目需要做数据库迁移，但是项目的war包和源码都找不到了，唯一能拿到的地方就是现在正在运行的容器和镜像库里对应的镜像。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>官方已经提供了修改运行容器，然后从容器重新打镜像上传的方案。例如，你需要对官方的centos7镜像修改并重新打镜像上传。</p>
<h3 id="第一步-进入需要修改的镜像"><a href="#第一步-进入需要修改的镜像" class="headerlink" title="第一步 进入需要修改的镜像"></a>第一步 进入需要修改的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -it centos:7 /bin/sh</div></pre></td></tr></table></figure>
<h3 id="第二步-做相应修改，例如安装软件后退出"><a href="#第二步-做相应修改，例如安装软件后退出" class="headerlink" title="第二步 做相应修改，例如安装软件后退出"></a>第二步 做相应修改，例如安装软件后退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install docker</div></pre></td></tr></table></figure>
<p>安装完成之后用exit退出。</p>
<h3 id="第三步-用docker-commit从容器打包镜像"><a href="#第三步-用docker-commit从容器打包镜像" class="headerlink" title="第三步 用docker commit从容器打包镜像"></a>第三步 用docker commit从容器打包镜像</h3><p>用<code>docker ps -a</code>找到第二步退出的目前已为exit状态的容器id。然后执行如下命令重新打镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit -m &quot;add docker&quot; -a &quot;angrytester&quot; 容器id centos:7-beta</div></pre></td></tr></table></figure>
<p>之后用<code>docker images</code>就能在本地找到重新打好的镜像。如果希望上传到镜像库，则可使用<code>docker push centos:7-beta</code></p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="容器启动一闪而过"><a href="#容器启动一闪而过" class="headerlink" title="容器启动一闪而过"></a>容器启动一闪而过</h3><p>如果参考以上操作修改tomcat镜像后重新上传启动容器，会发现tomcat容器无法启动（启动一下就默认退出），这个问题困扰了我整整一天。</p>
<p>原因是因为通过<code>/bin/sh</code>进入容器，会将镜像默认的入口覆盖，例如tomcat镜像默认入口是<code>catalina.sh run</code>，覆盖之后相当于启动容器时默认执行<code>/bin/sh</code>,非长时进程，因此容器启动一下就会自动跳出。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>我想到的有两个解决办法，一个是在启动时重新指定启动入口，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run tomcat:7 catalina.sh run</div></pre></td></tr></table></figure>
<p>另外一个是重新定义一个Dockerfile，打镜像，在Dockerfile中指定容器入口。</p>
<hr>
<p>2.21更新</p>
<p>还有一种方法是启动容器之后，通过<code>docker exec</code>进入容器进行修改，然后再用<code>docker commit</code>打镜像。</p>
<p>这样做的好处是打出来的镜像入口不会被覆盖。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/17/Pipeline-As-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/Pipeline-As-Code/" itemprop="url">Pipeline As Code</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-17T16:54:52+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>常见的Jenkins持续交付管道是基于Build Pipeline View插件的，实际上是通过另外新建一个视图来将原本没有关系的Job串联在一起，构成“管道”视图。这种方式的好处在于实现简单，不需要变更使用习惯。
　　</p>
<p>但是随着持续交付管道应用的深入，渐渐会发现这种方式的种种弊端：</p>
<ul>
<li><p>与“管道流”的初衷违背。由于各个交付节点实际上是各自分离的独立Job，所以每一个Job会在都是在自己的独立工作空间进行构建任务。这与“管道流”的初衷-上一节点的合格交付物流入下一节点-是违背的，因为各个Job的交付物其实是没有直接关联的；</p>
</li>
<li><p>Job维护工作量大。由于每一个交付管道的节点数众多，意味着每一条交付管道需要你维护多个Job，然后再将各个Job串联。因此，你可能需要花费大量时间来维护多个Job配置；</p>
</li>
<li><p>交付反馈流程可能存在冗余。由于各个Job都有自己独立的工作空间，各个工作空间是无法直接交互的。为了尽早反馈，我们希望将反馈节点尽量分割开，比如单元测试和静态扫描我们会分离成两个Job，但是静态扫描实际会依赖单元测试的产物（主要是覆盖率jacoco文件），所以导致单元测试可能会在单元测试和静态扫描环节重复执行，同样的情况还存在于编译打包和部署环节。</p>
</li>
</ul>
<p>　　<br>因此，我们适时考虑Jenkins官方推荐的Pipeline As Code。
　　</p>
<h3 id="Jenkins的Pipeline-As-Code示例"><a href="#Jenkins的Pipeline-As-Code示例" class="headerlink" title="Jenkins的Pipeline As Code示例"></a>Jenkins的Pipeline As Code示例</h3><p>熟悉Travis CI或GitLab CI的同事会发现，他们的持续集成与Jenkins的持续集成非常不一样。Travis CI和GitLab CI都依赖自己的配置文件（Travis是yaml，GitLab是yml）来实现持续交付管道，这就是Pipeline As Code的实现。</p>
<p>Jenkins的2.0版本号称是最大的一次变革，最主要也是因为开始支持Pipeline As Code来定义持续交付流程了。下面，我们会以实例来介绍Jenkins的Pipeline As Code。</p>
<p>首先，Jenkins的Pipeline As Code也是基于Jenkins的插件-Pipeline（关于这点笔者有话说，Jenkins的插件机制使得Jenkins的功能增强非常方便，但是同时业界也不少人担心陷入“插件地狱”，所以奉劝各位尽量少装插件，后面介绍基于Docker的持续交付方案中也会介绍如何避免装各种插件）。</p>
<p>在安装好Jenkins的Pipeline插件之后，在新建页面就能看到Pipeline选项了。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/newpipeline.jpg" alt="">
　　</p>
<p>新建Pipeline之后进入配置页面，会发现里面少了很多常规配置项，主要内容只有一个Pipeline Script，这里的Pipeline Script就是你的Pipeline脚本。</p>
<p>下拉选择示例脚本，Github+Maven：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/pipelinescript.jpg" alt="">
　　</p>
<p>我们一行一行看一下含义：</p>
<ul>
<li><p>第一行node：代表后面跟的大括号里的构建脚本将在哪个节点上运行，如果是空，则默认在master节点，否则可以写做node(“slave”)，这里的slave是你的节点名称。</p>
</li>
<li><p>def  mvnHome：定义一个变量mvnHome，因为Jenkins的Pipeline脚本是基于Groovy语言的，所以里面可以直接使用Groovy的一些语言特性，包括这里的定义变量以及后面的逻辑语句。</p>
</li>
<li><p>stage(‘Preparation’)：定义一个交付节点，代表后面跟的大括号里的脚本统一定义为一个交付节点，节点名称为“Preparation”，有点类似之前方案中的持续交付管道的Job名称。</p>
</li>
<li><p>git ‘<a href="https://github.com/jglick/simple-maven-project-with-tests.git&#39;:获取指定git版本库的代码。这种格式是如何定义的呢？可以通过下方的Pipeline" target="_blank" rel="external">https://github.com/jglick/simple-maven-project-with-tests.git&#39;:获取指定git版本库的代码。这种格式是如何定义的呢？可以通过下方的Pipeline</a> Syntax链接跳转到新页面进行调试。</p>
</li>
</ul>
<p>例如如果希望获取某个git库的代码，选择git后填写好相应信息，点击Generate Pipeline Script，就会生成对应代码：</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/git.jpg" alt=""></p>
<p>上面的例子不用输入git用户名密码，是因为配置了git的SSH Key。可参考：<a href="http://blog.csdn.net/fenglailea/article/details/39317513。" target="_blank" rel="external">http://blog.csdn.net/fenglailea/article/details/39317513。</a></p>
<ul>
<li>mvnHome = tool ‘M3’：变量赋值。M3是哪里配置的呢？在装好Maven插件之后，系统管理里增加Maven时的命令。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/maven.jpg" alt=""> </p>
<p>“M3”就应该替换成“apache-maven-3.3.9”。</p>
<ul>
<li><p>stage(‘Build’)：定义另一个交付节点，代表后面跟的大括号里的脚本统一定义为一个交付节点，节点名称为“Build”。</p>
</li>
<li><p>if (isUnix())：判断服务器是否为Unix系列，与后面的大括号共同形成逻辑判断语句。</p>
</li>
<li><p>sh “‘${mvnHome}/bin/mvn’ -Dmaven.test.failure.ignore clean package”：如果服务器为Unix系列，则执行这段bash，${mvnHome}为前面定义的变量mvnHome的值。</p>
</li>
<li><p>bat(/“${mvnHome}\bin\mvn” -Dmaven.test.failure.ignore clean package/)：如果服务器不为Unix（即为Windows系列），则执行这段bat。</p>
</li>
<li><p>stage(‘Results’)：定义另一个交付节点，代表后面跟的大括号里的脚本统一定义为一个交付节点，节点名称为“’Results’”。</p>
</li>
<li><p>junit ‘<em>*/target/surefire-reports/TEST-</em>.xml’：发布junit测试结果，后面为junit执行产生的xml文件地址。</p>
</li>
<li><p>archive ‘target/*.jar’：存档文件，后面内容为存档文件路径。
　　
　　</p>
</li>
</ul>
<h3 id="Pipeline的执行效果如下图所示："><a href="#Pipeline的执行效果如下图所示：" class="headerlink" title="Pipeline的执行效果如下图所示："></a>Pipeline的执行效果如下图所示：</h3><p>　　<br><img src="https://raw.githubusercontent.com/AngryTester/blog/master/pipeline.jpg" alt=""></p>
<h3 id="Pipeline-As-Code的优势"><a href="#Pipeline-As-Code的优势" class="headerlink" title="Pipeline As Code的优势"></a>Pipeline As Code的优势</h3><p>从上面的示例脚本可以看出来，Build节点的产物如Jar包在最后的Result节点就可以直接存档了。这与管道流的概念不谋而合，下一个节点的产物应该来自于上一个节点。</p>
<ul>
<li><p>以上示例脚本相当于完成了3个Job，所以维护工作相比之前的方式大大减少了。</p>
</li>
<li><p>由于整个管道都是在同一个工作空间，所以各个交付节点的产物都可以复用。之前存在的单元测试需要执行两遍的冗余就不存在了。</p>
</li>
<li><p>目前有个项目已经将传统的管道改成了Pipeline As Code的方式，完整的代码检出，编译打包，单元测试，静态扫描，依赖检查，测试环境部署整条管道花费15分钟以内，相比之前的方式（30分钟）整整节约了一倍时间。
　　</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3></li>
</ul>
<p>随着软件行业的发展，越来越重视团队的整体性，不管是开发、测试、运维，都应该围绕共同目标努力，共同目标就是交付满足客户需求的成果。Jenkins的Pipeline As Code也支持从版本库中读取管道脚本文件。</p>
<p>这意味着项目团队可以把管道脚本文件和项目的其他配置文件一样纳入版本控制系统统一管理。这其实也对应了团队的整体性。通过这种方式团队可以非常自如地定义自己的持续交付管道，同时也降低了对持续集成环境的高度依赖，以前新增一个管道需要新增各个Job，然后再各个Job进行配置，配置的工作通常由中心的持续集成环境运维人员来完成或由项目组指定的持续集成环境运维人员来完成，而把管道用脚本文件来实现并纳入版本控制，团队成员都有职责来确保脚本的正确性。</p>
<p>敏捷、DevOps、Docker等各种概念都强调团队共同交付一个整体，包括软件代码、运行环境以及交付过程中的一些依赖配置。后续介绍基于Docker和PaaS的Pipeline As Code也会印证这一目标。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/基于云平台的持续交付/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AngryTester">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AngryTester">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/基于云平台的持续交付/" itemprop="url">基于云平台的持续交付</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-15T09:03:09+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基于Docker环境下的持续交付画的一张图，感觉还是比较合适的。</p>
<p><img src="https://raw.githubusercontent.com/AngryTester/blog/master/CD.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">AngryTester</p>
              <p class="site-description motion-element" itemprop="description">起点不论好坏，终点始终美好！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AngryTester</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
