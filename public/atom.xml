<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AngryTester</title>
  
  <subtitle>起点不论好坏，终点始终美好！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-16T03:54:57.176Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AngryTester</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过noVNC远程监控自动化测试执行过程</title>
    <link href="http://yoursite.com/2019/08/16/%E9%80%9A%E8%BF%87noVNC%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/16/通过noVNC远程监控自动化测试执行过程/</id>
    <published>2019-08-16T03:52:26.000Z</published>
    <updated>2019-08-16T03:54:57.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>自动化测试追求的是无人值守，因此执行过程的监控就是鸡肋，但是在遇到以下场景时情况可能就有所不同：</p><ul><li><p>除了实时日志外希望输出更丰富的执行过程内容</p></li><li><p>需要给领导汇报自动化测试工作</p></li></ul><p>其中第二点尤为关键，对于不熟悉自动化测试的领导来说，可视化的执行视图对于领导来说会显得更友好且直观。</p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>对于Chrome和Firefox这类可运行在Linux环境下的前端自动化测试来说，已有前人种树，直接乘凉即可。可直接使用<a href="https://github.com/elgalu/docker-selenium" target="_blank" rel="external">docker-selenium</a>，因此难点主要在于只能运行于Windows环境下的IE浏览器。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>整体方案包括<code>Selenium Grid+UltraVNC+noVNC+websockify</code>。操作步骤如下：</p><ul><li><p>Selenium Grid的环境配置无需赘述。</p></li><li><p>安装UltraVNC。</p></li><li><p>安装NodeJS。</p></li><li><p>安装相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install ws</div><div class="line">npm install optimist</div><div class="line">npm install @novnc/novnc</div></pre></td></tr></table></figure></li><li><p>下载<a href="http://github.com/kanaka/noVNC/zipball/master" target="_blank" rel="external">noVNC</a>,解压至<code>node_modules</code>文件夹。</p></li><li><p>下载<a href="https://github.com/novnc/websockify-js/archive/master.zip" target="_blank" rel="external">Wesockify</a>,解压至<code>node_modules\noVNC</code>文件夹。</p></li><li><p>配置UltraVNC，去掉密码要求。进入UltraVNC安装目录找到配置文件，在配置文件中增加配置<code>AuthRequired=0</code>，然后将UltraVNC密码设置为空。</p></li><li><p>修改<code>vnc.html</code>，在body最后增加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">      window.onload=function()&#123;</div><div class="line">          var timer = setTimeout(() =&gt; &#123;</div><div class="line">           clearTimeout(timer)</div><div class="line">           document.getElementById(&quot;noVNC_connect_button&quot;).click();</div><div class="line">          &#125;, 500);</div><div class="line">      &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></li><li><p>运行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node C:\Users\Administrator\node_modules\noVNC\websockify-js-master\websockify\websockify.js --web C:\Users\Administrator\node_modules\noVNC 9000 localhost:5900</div></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>通过<a href="http://服务器IP:9000即可浏览器访问服务器实时页面效果。" target="_blank" rel="external">http://服务器IP:9000即可浏览器访问服务器实时页面效果。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;why&quot;&gt;&lt;a href=&quot;#why&quot; class=&quot;headerlink&quot; title=&quot;why&quot;&gt;&lt;/a&gt;why&lt;/h2&gt;&lt;p&gt;自动化测试追求的是无人值守，因此执行过程的监控就是鸡肋，但是在遇到以下场景时情况可能就有所不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;除
      
    
    </summary>
    
    
      <category term="自动化测试" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>TCPClient模式输出精准测试覆盖率</title>
    <link href="http://yoursite.com/2019/07/29/TCPClient%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%87%BA%E7%B2%BE%E5%87%86%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>http://yoursite.com/2019/07/29/TCPClient模式输出精准测试覆盖率/</id>
    <published>2019-07-29T09:05:15.000Z</published>
    <updated>2019-07-29T09:06:31.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JaCoCo-agent运行数据的4种输出模式"><a href="#1-JaCoCo-agent运行数据的4种输出模式" class="headerlink" title="1. JaCoCo agent运行数据的4种输出模式"></a>1. JaCoCo agent运行数据的4种输出模式</h2><p>参考JaCoCo官方文档：</p><blockquote><p>The JaCoCo agent collects execution information and dumps it on request or when the JVM exits. There are three different modes for execution data output:<br><br><br>File System: At JVM termination execution data is written to a local file.<br>TCP Socket Server: External tools can connect to the JVM and retrieve execution data over the socket connection. Optional execution data reset and execution data dump on VM exit is possible.<br>TCP Socket Client: At startup the JaCoCo agent connects to a given TCP endpoint. Execution data is written to the socket connection on request. Optional execution data reset and execution data dump on VM exit is possible.</p></blockquote><p>一共有三种模式可以输出运行数据，分别是：</p><ul><li>文件模式：JVM终止时会将运行数据写入一个本地文件。</li><li>TCP Socket Server模式：可以通过外部工具Socket连接到JVM获取实时运行数据。JVM终止时运行数据重置并导出。</li><li>TCP Socket Client模式：启动时agent会连接到提供的一个TCP终端。运行数据会持续往这个socket连接写入。JVM终止时运行数据重置并导出。</li></ul><h2 id="2-各种模式的使用场景"><a href="#2-各种模式的使用场景" class="headerlink" title="2. 各种模式的使用场景"></a>2. 各种模式的使用场景</h2><p>三种模式并无本质区别，可根据实际使用场景选择。</p><p>比较常见的是使用TCPServer模式，在JVM启动命令中增加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-javaagent:/opt/pmo/jacocoagent.jar=includes=*,output=tcpserver,port=2014,address=*</div></pre></td></tr></table></figure><p>即在JVM启动同时在<code>2014</code>端口启动另外一个TCPServer，然后使用官方的cli工具dump即可将运行数据导出到本地文件。</p><p>以上模式在传统部署模式下比较方便，但是在容器化部署环境中，由于TCPServer需要单独占用一个端口，对于一些实用<code>ingress</code>的方案中，只能通过域名方式将端口映射到宿主机上，但是dump工具不支持连接ingress暴露的域名，因此这种方式不适合，因此需要考虑采用其他模式。</p><p>文件模式会将文件导出在JVM所在服务器，即处于容器内部，这种显然也不符合实际需求，因此考虑采用TCPClient模式。</p><h2 id="3-TCPClient模式配置"><a href="#3-TCPClient模式配置" class="headerlink" title="3. TCPClient模式配置"></a>3. TCPClient模式配置</h2><h3 id="3-1-启动TCPServer"><a href="#3-1-启动TCPServer" class="headerlink" title="3.1 启动TCPServer:"></a>3.1 启动<a href="https://www.jacoco.org/jacoco/trunk/doc/examples/java/ExecutionDataServer.java" target="_blank" rel="external">TCPServer</a>:</h3><p>核心代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       // 导出文件绝对路径</div><div class="line">private static final String DESTFILE = &quot;jacoco-server.exec&quot;;</div><div class="line">       // 启动的服务器IP，注意实际使用中修改为IP，不要用localhost</div><div class="line">private static final String ADDRESS = &quot;localhost&quot;;</div><div class="line">       // 启动的服务器端口</div><div class="line">private static final int PORT = 6300;</div></pre></td></tr></table></figure></p><h3 id="3-2-增加启动配置"><a href="#3-2-增加启动配置" class="headerlink" title="3.2 增加启动配置"></a>3.2 增加启动配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-javaagent:/opt/pmo/jacocoagent.jar=includes=*,output=tcpclient,port=6300,address=10.25.74.82</div></pre></td></tr></table></figure><p>在JVM停止时就会自动将运行数据导出到第一步中指定的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JaCoCo-agent运行数据的4种输出模式&quot;&gt;&lt;a href=&quot;#1-JaCoCo-agent运行数据的4种输出模式&quot; class=&quot;headerlink&quot; title=&quot;1. JaCoCo agent运行数据的4种输出模式&quot;&gt;&lt;/a&gt;1. JaCoCo 
      
    
    </summary>
    
    
      <category term="精准测试" scheme="http://yoursite.com/tags/%E7%B2%BE%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    
      <category term="jacoco" scheme="http://yoursite.com/tags/jacoco/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-十二-敏捷误区</title>
    <link href="http://yoursite.com/2019/06/06/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E5%8D%81%E4%BA%8C-%E6%95%8F%E6%8D%B7%E8%AF%AF%E5%8C%BA/"/>
    <id>http://yoursite.com/2019/06/06/我所经历的以及我所理解的敏捷-十二-敏捷误区/</id>
    <published>2019-06-06T00:45:48.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sprint不是小的瀑布模型"><a href="#Sprint不是小的瀑布模型" class="headerlink" title="Sprint不是小的瀑布模型"></a>Sprint不是小的瀑布模型</h2><p>将Sprint理解为小瀑布是最常见的误区，例如以前一个版本持续2个月，现在将其划分为4个小版本，每个版本持续2周，但是工作方式还延续之前瀑布模式的做法，遵循严格的需求-开发-测试的流转，可预见的是测试的压力会比之前大瀑布的时期更大。</p><h2 id="其他误区"><a href="#其他误区" class="headerlink" title="其他误区"></a>其他误区</h2><ul><li>敏捷就是快，版本更新很快，甚至每天都有新版本</li></ul><blockquote><p>将版本更新速度视为敏捷开发核心，是完全错误的。不是发现一个bug，就改一个发布一个，而是收集反馈，统一修订后，再发布新版本。这里是指发布，而在开发过程中频繁提测是允许的。</p></blockquote><ul><li>敏捷意味着不需要文档</li></ul><blockquote><p>不需要利用率太低，可读性差，格式复杂死板，更新太频繁的文档。需要图形化，模块化，可视化程度高，逻辑详细完整准确，容易传播的文档。敏捷非常推荐活文档，例如遵循BDD原则开发的测试文档。</p></blockquote><ul><li>敏捷是快速开发，迭代版本的BUG多一点是正常的</li></ul><blockquote><p>每个交付的产品，必须是集成测试通过的。宁可交付产品数量少，也不能降低质量。</p></blockquote><ul><li>采用敏捷方法的开发组/项目不需要制定计划</li></ul><blockquote><p>敏捷项目需要经常制定计划，但是不需要试图超前制定项目计划，通常这也是不可能的。</p></blockquote><ul><li>敏捷项目的范围可以随时改变</li></ul><blockquote><p>变更可以等到下一次迭代开始，当前正在进行中的迭代不能变更</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Sprint不是小的瀑布模型&quot;&gt;&lt;a href=&quot;#Sprint不是小的瀑布模型&quot; class=&quot;headerlink&quot; title=&quot;Sprint不是小的瀑布模型&quot;&gt;&lt;/a&gt;Sprint不是小的瀑布模型&lt;/h2&gt;&lt;p&gt;将Sprint理解为小瀑布是最常见的误区，例
      
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-十一-精益开发&amp;极限编程</title>
    <link href="http://yoursite.com/2019/06/06/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E5%8D%81%E4%B8%80-%E7%B2%BE%E7%9B%8A%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/06/06/我所经历的以及我所理解的敏捷-十一-精益开发/</id>
    <published>2019-06-06T00:31:18.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="精益的历史"><a href="#精益的历史" class="headerlink" title="精益的历史"></a>精益的历史</h2><p>来源于1890年代的欧洲的手工艺生产，1910年代的美国福特公司用于工业生产，1950年代的日本丰田公司发扬光大，1990年代美国提出精益管理。</p><h2 id="精益开发原则"><a href="#精益开发原则" class="headerlink" title="精益开发原则"></a>精益开发原则</h2><ul><li><p>消除浪费</p></li><li><p>构建完整性</p></li><li><p>强化学习</p></li><li><p>尽可能晚做决策</p></li><li><p>尽可能早交付</p></li><li><p>尊重授权团队</p></li><li><p>全盘优化</p></li></ul><h2 id="KANBAN原则"><a href="#KANBAN原则" class="headerlink" title="KANBAN原则"></a>KANBAN原则</h2><ul><li><p>可视化工作流</p></li><li><p>限制在制品数量</p></li><li><p>管理工作流</p></li><li><p>保证流程规范清楚明确</p></li><li><p>加强合作</p></li></ul><h2 id="Scrum-VS-KANBAN"><a href="#Scrum-VS-KANBAN" class="headerlink" title="Scrum VS KANBAN"></a>Scrum VS KANBAN</h2><table><thead><tr><th>Scrum</th><th>KANBAN</th></tr></thead><tbody><tr><td>设置时间盒</td><td>时间盒是可选的</td></tr><tr><td>团队预先选择每个冲刺的工作</td><td>预先选择工作是可选的</td></tr><tr><td>跨职能团队</td><td>除了跨职能团队，专家团队也是可选的</td></tr><tr><td>间接限定WIP（时间盒）</td><td>直接限制WIP</td></tr><tr><td>必须要有估算（不用精确）</td><td>估算是可选的</td></tr><tr><td>每个Sprint中不能改变工作</td><td>随时可以增加工作量，只要容量允许（WIP限定）</td></tr><tr><td>一个Sprint Backlog由一个研发Team负责</td><td>一个Kanban可以由多个Team分享</td></tr><tr><td>Scrum Board会在每个冲刺之间重置</td><td>Kanban Board是可选的</td></tr></tbody></table><h2 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h2><p>XP，我们一般称为极限编程，是最轻量级的开发流程。最主要的精神是：在客户有系统需求时，给予及时满意的可执行程序，所以最适合需求快速变动的项目。</p><p>它强调：客户所要的是可工作的执行代码，所以把鱼撰写程序无关的工作降至最低，并要求客户与开发人员最好以side-by-side的方式一起工作。</p><h2 id="XP的价值观"><a href="#XP的价值观" class="headerlink" title="XP的价值观"></a>XP的价值观</h2><ul><li><p>简单</p></li><li><p>沟通</p></li><li><p>反馈</p></li><li><p>勇气</p></li><li><p>尊重</p></li></ul><h2 id="XP的12个实践"><a href="#XP的12个实践" class="headerlink" title="XP的12个实践"></a>XP的12个实践</h2><ul><li><p>计划游戏</p></li><li><p>小版本发布</p></li><li><p>隐喻</p></li><li><p>测试驱动开发</p></li><li><p>重构</p></li><li><p>结对编程</p></li><li><p>代码集体所有</p></li><li><p>持续集成</p></li><li><p>可持续的开发速度</p></li><li><p>客户测试</p></li><li><p>编码规范</p></li></ul><h2 id="XP的角色"><a href="#XP的角色" class="headerlink" title="XP的角色"></a>XP的角色</h2><ul><li><p>XP教练</p></li><li><p>XP客户</p></li><li><p>XP程序员</p></li><li><p>XP测试员</p></li><li><p>XP跟踪员</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;精益的历史&quot;&gt;&lt;a href=&quot;#精益的历史&quot; class=&quot;headerlink&quot; title=&quot;精益的历史&quot;&gt;&lt;/a&gt;精益的历史&lt;/h2&gt;&lt;p&gt;来源于1890年代的欧洲的手工艺生产，1910年代的美国福特公司用于工业生产，1950年代的日本丰田公司发扬光大，1
      
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-十-Scrum中的仪式</title>
    <link href="http://yoursite.com/2019/06/05/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E5%8D%81-Scrum%E4%B8%AD%E7%9A%84%E4%BB%AA%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/05/我所经历的以及我所理解的敏捷-十-Scrum中的仪式/</id>
    <published>2019-06-05T00:30:05.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四场仪式"><a href="#四场仪式" class="headerlink" title="四场仪式"></a>四场仪式</h2><p>Scrum中共有四场仪式，分别是<code>计划会</code>,<code>站会</code>,<code>评审会</code>,<code>回顾会</code>。</p><h2 id="计划会"><a href="#计划会" class="headerlink" title="计划会"></a>计划会</h2><p>计划会的目标是创建冲刺计划（Sprint Backlog），又可以细分为：</p><ul><li><p>从<code>Product Backlog</code>中选择要处理的事务</p></li><li><p>选定的用户故事则为Sprint目标</p></li><li><p>将用户故事拆分为Tasks</p></li></ul><p>计划会也是一个时间盒，通常一个月的Sprint计划会时间不宜超过8个小时（即一个工作日）。</p><p>在实际实施中，通常会按照以下两个步骤操作：</p><ul><li><p>按照Product Backlog中排列的优先级从高到低对条目进行估算，不用全部估算完，估算的条目数够用即可</p></li><li><p>按照团队以往的交付速率，选取按照平均速率团队在一个Sprint中能够完成的条目加入到Sprint Backlog</p></li></ul><h3 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h3><p>在我们以往的实施经历中，<code>估算</code>一直是一个难题，由于对故事细节的理解不清晰，估算通常与实际相差很大。但就个人经验来说，估算的目的并不是为了精确估算，而是通过这种形式能够促使开发团队能够尽量去理解故事细节，另外通过开发团队提问，产品负责人澄清的方式，也能够帮助产品负责人下次写出更清晰的用户故事。</p><p>估算有以下几个要点：</p><ul><li><p>估算不是承诺，不存在事后追责</p></li><li><p>相对估算，即可以选择一个大小适中的用户故事作为1个故事点的参照，其他用户故事可参考进行相对估算。</p></li><li><p>也可使用理想时长作为估算单位，所谓理想时长是指全身心投入的时长（我们经常举的例子是把所有伸懒腰倒茶喝水上厕所的时间全部不计算进去）</p></li></ul><p>对于用户故事特别多的情况，有一种叫做<code>快速排序</code>的方法，具体操作是：</p><ul><li><p>将所有用户故事按照估算大小排好，大小差不多的可以放在同一列。</p></li><li><p>按照斐波那契数列直接给所有用户故事赋上故事点数。（1/2,1,2,3,5,8,13…）</p></li></ul><p>个人理解选取斐波那契数列而不选用连续自然数的原因是因为强调是估算，故事越大的时候估算必然是越不准的，所以无需纠结1-2点的误差。</p><p>估算故事点的主要意义除了促使开发团队提前理解用户故事和帮助产品负责人写出更好的用户故事，还有另外一个比较重要的意义是估算团队交付速率，团队交付速率可用于：</p><ul><li><p>预测项目完成日期</p></li><li><p>计划下个Sprint的交付能力</p></li></ul><p>理想的情况团队交付速率应该前期呈上升趋势，到一定时间开始趋于平稳。</p><h2 id="站会"><a href="#站会" class="headerlink" title="站会"></a>站会</h2><p>站会也是一个时间盒，通常每日站会时间不超过15分钟，站会的主要目的是开发者之间的信息<code>同步</code>，信息同步的主要价值以个人经历来说，在于识别目前存在的瓶颈，最典型的是一个简单问题可能导致某一个项目成员的进度停滞，而通过信息同步，其他项目成员帮助其快速解决遇到的瓶颈。</p><blockquote><p>团队成员应该将团队目标作为主要目标，可能自己钻研能够帮助到自己的成长，但是在团队目标面前，应该优先考虑团队目标的达成。</p></blockquote><p>站会上通常每个人会回答以下3个问题：</p><ul><li><p>上个Daily Scrum到现在，我做了什么</p></li><li><p>到下个Daily Scrum之前我准备做什么</p></li><li><p>我遇到了什么问题</p></li></ul><h2 id="评审会"><a href="#评审会" class="headerlink" title="评审会"></a>评审会</h2><p>评审会也是一个时间盒，通常一个月的Sprint评审会时间不超过4个小时。评审会的主要内容是Scrum团队给客户演示增量并接收客户反馈，从而更好为之后的迭代改进提供输入。</p><p>评审会体现的是敏捷中的适应性。</p><h2 id="回顾会"><a href="#回顾会" class="headerlink" title="回顾会"></a>回顾会</h2><p>回顾会也是一个时间盒，通常一个月的Sprint回顾会时间不超过3个小时。回顾会的主要内容是Scrum团队回顾当前迭代过程，分析存在的异常，总结改进措施作为下一个迭代的待办项。</p><p>在以往实施经历中，通常会把回顾会的气氛搞得相对轻松些，回顾会不是追责会，需要让大家畅所欲言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四场仪式&quot;&gt;&lt;a href=&quot;#四场仪式&quot; class=&quot;headerlink&quot; title=&quot;四场仪式&quot;&gt;&lt;/a&gt;四场仪式&lt;/h2&gt;&lt;p&gt;Scrum中共有四场仪式，分别是&lt;code&gt;计划会&lt;/code&gt;,&lt;code&gt;站会&lt;/code&gt;,&lt;code&gt;评审会&lt;/co
      
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-九-Scrum中的角色</title>
    <link href="http://yoursite.com/2019/06/04/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E4%B9%9D-Scrum%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2/"/>
    <id>http://yoursite.com/2019/06/04/我所经历的以及我所理解的敏捷-九-Scrum中的角色/</id>
    <published>2019-06-04T00:14:51.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scrum中的三种角色"><a href="#Scrum中的三种角色" class="headerlink" title="Scrum中的三种角色"></a>Scrum中的三种角色</h2><ul><li><p>Product Owner-PO，关注于商业价值</p></li><li><p>Scrum Master-SM,Scrum专家</p></li><li><p>Development Team-DT，技术人员</p></li></ul><h2 id="Scrum团队的特点"><a href="#Scrum团队的特点" class="headerlink" title="Scrum团队的特点"></a>Scrum团队的特点</h2><ul><li><p>自组织。自组织确保了充分发挥团队主观能动性。</p></li><li><p>跨职能。跨职能确保了团队拥有充分的技能能够高效完成工作。</p></li></ul><p>敏捷团队没有额外的角色（例如项目经理），没有岗位名称，一切以消除职级差异为主。</p><h2 id="Scrum的工作地点"><a href="#Scrum的工作地点" class="headerlink" title="Scrum的工作地点"></a>Scrum的工作地点</h2><ul><li><p>相同地点办公（确保渗透式沟通，所以渗透式沟通有点”耳濡目染”的意思，即不经意间接收到信息）</p></li><li><p>面对面沟通</p></li><li><p>可变化的价值</p></li></ul><h2 id="SM的职责"><a href="#SM的职责" class="headerlink" title="SM的职责"></a>SM的职责</h2><ul><li><p>对过程负责（不对解决方案负责，也不对人负责）</p></li><li><p>确保Scrum被正确理解及贯彻</p></li><li><p>教练以及问题解决</p></li><li><p>清除障碍</p></li><li><p>保护团队</p></li><li><p>促进各项活动开展</p></li></ul><h2 id="PO的职责"><a href="#PO的职责" class="headerlink" title="PO的职责"></a>PO的职责</h2><ul><li><p>对Product Backlog负责（交付价值）</p></li><li><p>创建产品条目</p></li><li><p>对产品条目进行排序</p></li><li><p>澄清需求</p></li></ul><h2 id="DT的职责"><a href="#DT的职责" class="headerlink" title="DT的职责"></a>DT的职责</h2><ul><li><p>完成Sprint Backlig</p></li><li><p>自组织</p></li><li><p>估算</p></li><li><p>更新信息发射源，所谓信息发射源是指所有能够提供团队成员能够接收到信息的一切介质，最常见的就是看板。</p></li><li><p>报告</p></li><li><p>ETC…</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Scrum中的三种角色&quot;&gt;&lt;a href=&quot;#Scrum中的三种角色&quot; class=&quot;headerlink&quot; title=&quot;Scrum中的三种角色&quot;&gt;&lt;/a&gt;Scrum中的三种角色&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Product Owner-PO，关注于商业价值&lt;
      
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-八-User Story</title>
    <link href="http://yoursite.com/2019/06/04/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E5%85%AB-User-Story/"/>
    <id>http://yoursite.com/2019/06/04/我所经历的以及我所理解的敏捷-八-User-Story/</id>
    <published>2019-06-04T00:07:46.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用户故事是由<code>Product Owner</code>编写的，描述对用户有价值功能。</p><h2 id="故事三要素"><a href="#故事三要素" class="headerlink" title="故事三要素"></a>故事三要素</h2><p>角色:谁</p><p>功能：要什么</p><p>价值：为什么要</p><h2 id="好的用户故事的特征"><a href="#好的用户故事的特征" class="headerlink" title="好的用户故事的特征"></a>好的用户故事的特征</h2><ul><li><p>Independent，独立性确保了排序的可行性</p></li><li><p>Negotiable，可协商体现从用户价值出发，待办列表不等同于合同，根据用户需求的关注点可动态变化</p></li><li><p>Valuable，有价值是待办项的基本属性</p></li><li><p>Estimate-able，可估算代表团队已经清楚了工作内容和工作量大小</p></li><li><p>Small，足够小确保待办列表能够在一个迭代中完成</p></li><li><p>Testable，可测试代表团队已经清楚如何对待办项进行验收，即清楚了验收标准</p></li></ul><h2 id="User-Stroy-amp-Task"><a href="#User-Stroy-amp-Task" class="headerlink" title="User Stroy &amp; Task"></a>User Stroy &amp; Task</h2><p>在实际实施过程中，可能会遇到一些并不会对用户直接产生价值，但是又不得不做的事，例如技术预研。这类技术类事务，我们的做法是将其区分于用户故事，以任务的形式存在于待办列表中。但是这种做法可能走入另一个极端，将所有技术类事务全部设置为任务，例如单元测试实施，静态扫描问题修复等等，建议还是应该尽量将所有事项往用户故事上靠，通过设置故事的验收标准来将任务需要达成的目标融入用户故事中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;用户故事是由&lt;code&gt;Product Owner&lt;/code&gt;编写的，描述对用户有价值功能。&lt;/p&gt;
&lt;h2 id=&quot;故事三要素&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-七-Backlogs</title>
    <link href="http://yoursite.com/2019/06/03/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E4%B8%83-Backlogs/"/>
    <id>http://yoursite.com/2019/06/03/我所经历的以及我所理解的敏捷-七-Backlogs/</id>
    <published>2019-06-03T00:40:04.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Backlog</code>,中文通常译作<code>待办列表</code>，在Scrum中，又细分为<code>Product Backlog</code>(产品待办列表)和<code>Sprint Backlog</code>(迭代代办列表)。<code>Sprint Backlog</code>通常作为<code>Product Backlog</code>的子集。</p><h2 id="User-Stroy"><a href="#User-Stroy" class="headerlink" title="User Stroy"></a>User Stroy</h2><p>产品待办列表和迭代待办列表中的待办项在Scrum中称呼为<code>User Stroy</code>(用户故事)，用户故事的格式通常如下：</p><p><code>As A</code>…,<code>I want to</code>…,<code>so that</code>…，作为一个<code>角色</code>，我想要<code>功能</code>，以便于<code>商业价值</code>。</p><p>用户故事的描述的格式体现了从用户价值出发，从非技术的角度描述了故事最终体现的商业价值。</p><h2 id="Product-Backlog的基本特征"><a href="#Product-Backlog的基本特征" class="headerlink" title="Product Backlog的基本特征"></a>Product Backlog的基本特征</h2><p><code>Product Backlog</code>可以理解为产品想做的所有事。具体表现形式为一组排序的features列表，可能在敏捷实施过程中动态调整（包括调整优先级或者增删修改），且永远不会完成（若<code>Product Backlog</code>为空了则代表产品生命周期已完结）</p><p>其中<code>排序</code>作为<code>Product Backlog</code>的重要特征，可以根据价值高低进行调整。<code>Product Owner</code>承担了创建待办项和排序，澄清的职责。</p><p>待办列表内容描述应该尽量从非技术性的角度出发，且应该保证<code>Product Backlog</code>中的各个条目的相互独立性。总结来说，Scrum中的<code>Product Backlog</code>中的条目特征可以总结为<code>INVEST</code>:</p><ul><li><p>Independent，独立性确保了排序的可行性</p></li><li><p>Negotiable，可协商体现从用户价值出发，待办列表不等同于合同，根据用户需求的关注点可动态变化</p></li><li><p>Valuable，有价值是待办项的基本属性</p></li><li><p>Estimate-able，可估算代表团队已经清楚了工作内容和工作量大小</p></li><li><p>Small，足够小确保待办列表能够在一个迭代中完成</p></li><li><p>Testable，可测试代表团队已经清楚如何对待办项进行验收，即清楚了验收标准</p></li></ul><p><code>Product Backlog</code>的粒度会根据不同的类型而不同，其中越靠近当前迭代的用户故事粒度会小一些，越远的用户故事可能为<code>Epic</code>(史诗级故事)，在后续再进行细化。</p><h2 id="Product-Backlog梳理"><a href="#Product-Backlog梳理" class="headerlink" title="Product Backlog梳理"></a>Product Backlog梳理</h2><p>Product Backlog梳理的主要工作内容包括增加新的条目和细化条目，为持续性活动，不超过10%的开发时间。</p><h2 id="Sprint-Backlog"><a href="#Sprint-Backlog" class="headerlink" title="Sprint Backlog"></a>Sprint Backlog</h2><p><code>Sprint Backlog</code>通常作为<code>Product Backlog</code>的子集。基本特征与<code>Product Backlog</code>基本一致，其他附加特征如下：</p><ul><li><p><code>Sprint Backlog</code>由开发团队拥有，<code>Product Backlog</code>由<code>Product Owner</code>拥有。即开发团队可决定 <code>Sprint Backlog</code>的内容，<code>Product Owner</code>可决定<code>Product Backlog</code>的内容。</p></li><li><p>责任分摊，即<code>Sprint Backlog</code>的责任由开发团队公共分摊。</p></li><li><p>团队负责测量Sprint绩效。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Backlog&lt;/code&gt;,中文通常译作&lt;code&gt;待办列表&lt;/code&gt;，在Scrum中，又细分为&lt;code&gt;Product
      
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>mysql容器解决自动化测试数据初始化与销毁</title>
    <link href="http://yoursite.com/2019/05/20/mysql%E5%AE%B9%E5%99%A8%E8%A7%A3%E5%86%B3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81/"/>
    <id>http://yoursite.com/2019/05/20/mysql容器解决自动化测试数据初始化与销毁/</id>
    <published>2019-05-20T00:54:38.000Z</published>
    <updated>2019-07-30T10:39:58.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在自动化测试过程中可能遇到无法通过被测系统自身提供的功能对自动化测试产生的数据进行销毁的情况，通过直接执行DDL销毁数据在数据关系比较复杂的情况下可能带来未知异常，因此可以考虑使用容器作为数据源，通过容器的起停来达成测试数据自动初始化和销毁的目的。</p><h2 id="镜像制作流程"><a href="#镜像制作流程" class="headerlink" title="镜像制作流程"></a>镜像制作流程</h2><ul><li>启动mysql容器并将数据目录映射至宿主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name mysqldock -e MYSQL_ROOT_PASSWORD=123456 -d -p 3306:3066 -v /data:/var/lib/mysql mysql</div></pre></td></tr></table></figure><a id="more"></a><ul><li>进入容器允许mysql外部连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker exec -it mysqldocker /bin/bash</div><div class="line">mysql -uroot -p123456</div><div class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;</div></pre></td></tr></table></figure><ul><li><p>使用数据库连接工具连接上一步启动的数据库容器新建数据库并初始化数据</p></li><li><p>制作Dockerfile并制作镜像</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FROM mysql:latest</div><div class="line"></div><div class="line">COPY data /var/lib/mysql</div></pre></td></tr></table></figure><blockquote><p><code>data</code>文件夹为上面映射至宿主机的数据文件目录</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>mysql容器启动时会自动将数据文件主目录映射到宿主机上，<code>docker commit</code>无法将默认挂载的文件或目录打到镜像中，因此如果操作数据库添加数据之后直接使用<code>docker commit</code>制作镜像，添加的数据将不复存在,需要使用先将数据文件挂载到宿主机上，然后通过<code>Dockerfile</code>复制进去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;在自动化测试过程中可能遇到无法通过被测系统自身提供的功能对自动化测试产生的数据进行销毁的情况，通过直接执行DDL销毁数据在数据关系比较复杂的情况下可能带来未知异常，因此可以考虑使用容器作为数据源，通过容器的起停来达成测试数据自动初始化和销毁的目的。&lt;/p&gt;
&lt;h2 id=&quot;镜像制作流程&quot;&gt;&lt;a href=&quot;#镜像制作流程&quot; class=&quot;headerlink&quot; title=&quot;镜像制作流程&quot;&gt;&lt;/a&gt;镜像制作流程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;启动mysql容器并将数据目录映射至宿主机&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker run --name mysqldock -e MYSQL_ROOT_PASSWORD=123456 -d -p 3306:3066 -v /data:/var/lib/mysql mysql&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-六-Scrum</title>
    <link href="http://yoursite.com/2019/03/22/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E5%85%AD-Scrum/"/>
    <id>http://yoursite.com/2019/03/22/我所经历的以及我所理解的敏捷-六-Scrum/</id>
    <published>2019-03-22T00:54:14.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scrum全景图"><a href="#Scrum全景图" class="headerlink" title="Scrum全景图"></a>Scrum全景图</h2><p>Scrum本质上是一种在敏捷价值观指导下总结的实践方法。整个实践流程可用下图总结：</p><h2 id="Scrum的一个核心-Sprint"><a href="#Scrum的一个核心-Sprint" class="headerlink" title="Scrum的一个核心-Sprint"></a>Scrum的一个核心-Sprint</h2><p><code>Sprint</code>中文译名为冲刺，即为Scrum中的迭代，意指团队在这个期间全身心关注目标前进。</p><p>一个迭代中包含以下几项关键活动：<br><a id="more"></a></p><ul><li><p>Sprint Planning（计划会）</p></li><li><p>Daily Scrums（每日站会）</p></li><li><p>Sprint Review（评审会）</p></li><li><p>Sprint Retrospectiv（回顾会）</p></li></ul><h2 id="时间盒"><a href="#时间盒" class="headerlink" title="时间盒"></a>时间盒</h2><p>时间盒的要素包括：</p><ul><li><p>有最长持续时间</p></li><li><p>不可以临时拓展时长</p></li><li><p>聚焦价值</p></li></ul><blockquote><p>在Scrum中到处充斥着时间盒，例如每个迭代可以看作一个较大的时间盒，每天的冲刺活动也属于时间盒。在敏捷实施初期，我们还尝试过在每天的冲刺活动中再设置一些较小的时间盒，目的在于快速反馈，及时调整。因此在一个较年轻的敏捷团队开展初期，建议将时间盒的长度设置短一些，以便于在发现问题时能够及时调整。</p></blockquote><h2 id="在Sprint过程中不可改变的内容"><a href="#在Sprint过程中不可改变的内容" class="headerlink" title="在Sprint过程中不可改变的内容"></a>在Sprint过程中不可改变的内容</h2><ul><li><p>开发团队成员</p></li><li><p>Sprint计划</p></li><li><p>预期质量</p></li></ul><blockquote><p>实际操作中可能出现在Sprint后期临时减少迭代包含用户故事的情况，这种操作是极不推荐的，因为会打乱团队运转的规则，大家会越来越不重视敏捷计划。若出现在Sprint后期发现无法完成当前迭代规划的所有用户故事，应该在回顾会时讨论应对方案并应用至下个迭代。</p></blockquote><h2 id="Sprint取消"><a href="#Sprint取消" class="headerlink" title="Sprint取消"></a>Sprint取消</h2><ul><li><p>Sprint目标过时了</p></li><li><p>Product Owner的权利</p></li></ul><blockquote><p>第二种实际操作中基本是不会出现的，反正我们暂时没遇到过拥有这种权利的PO。</p></blockquote><h2 id="Sprint的目标"><a href="#Sprint的目标" class="headerlink" title="Sprint的目标"></a>Sprint的目标</h2><p>创建增量，包括：</p><ul><li><p>可运行的软件</p></li><li><p>对最终用户可用</p></li><li><p>潜在可发布</p></li><li><p>具有适应性</p></li></ul><blockquote><p>对于增量的理解对于敏捷团队坚持正确的做事方式来说尤为重要，什么叫做可运行的软件，什么叫对最终用户可用，唯一标准是可以设想你把功能交给客户希望客户先给一部分钱，如果客户愿意，即证明能够称得上是增量，否则你提交的就是半成品。其中潜在可发布的意思个人理解是说增量产物只需要达到可发布的标准即可，并非一定要发布。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Scrum全景图&quot;&gt;&lt;a href=&quot;#Scrum全景图&quot; class=&quot;headerlink&quot; title=&quot;Scrum全景图&quot;&gt;&lt;/a&gt;Scrum全景图&lt;/h2&gt;&lt;p&gt;Scrum本质上是一种在敏捷价值观指导下总结的实践方法。整个实践流程可用下图总结：&lt;/p&gt;
&lt;h2 id=&quot;Scrum的一个核心-Sprint&quot;&gt;&lt;a href=&quot;#Scrum的一个核心-Sprint&quot; class=&quot;headerlink&quot; title=&quot;Scrum的一个核心-Sprint&quot;&gt;&lt;/a&gt;Scrum的一个核心-Sprint&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Sprint&lt;/code&gt;中文译名为冲刺，即为Scrum中的迭代，意指团队在这个期间全身心关注目标前进。&lt;/p&gt;
&lt;p&gt;一个迭代中包含以下几项关键活动：&lt;br&gt;
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-四-敏捷计划</title>
    <link href="http://yoursite.com/2019/03/20/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E5%9B%9B-%E6%95%8F%E6%8D%B7%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/03/20/我所经历的以及我所理解的敏捷-四-敏捷计划/</id>
    <published>2019-03-20T00:30:07.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="适应性计划的必要性"><a href="#适应性计划的必要性" class="headerlink" title="适应性计划的必要性"></a>适应性计划的必要性</h2><p>敏捷的计划叫做适应性计划，意旨根据变化能够及时适应。为什么需要做适应性计划？</p><ul><li><p>项目的不确定性</p></li><li><p>敏捷项目是以价值为驱动</p></li><li><p>风险需要降低</p><a id="more"></a></li><li>环境不断的变化：市场、技术、外部因素</li></ul><blockquote><p>客户有时候可能没想清楚自己要什么，对自己不要什么是更有把握的。所以计划如果定的太死，应对客户看到你提交的东西提出变更时可能就比较困难了。</p></blockquote><h2 id="敏捷计划和瀑布式计划的区别"><a href="#敏捷计划和瀑布式计划的区别" class="headerlink" title="敏捷计划和瀑布式计划的区别"></a>敏捷计划和瀑布式计划的区别</h2><ul><li><p>敏捷关注真实需求，体现出渐进明细</p></li><li><p>敏捷计划关注与整个项目生命周期</p></li><li><p>敏捷计划需要及时对中期计划进行调整</p></li></ul><h2 id="敏捷计划的层次"><a href="#敏捷计划的层次" class="headerlink" title="敏捷计划的层次"></a>敏捷计划的层次</h2><ul><li><p>1.敏捷愿景（全生命周期）-整个项目想做什么</p></li><li><p>2.路线图（1年）-近一年想做什么</p></li><li><p>3.发布（6个月）-近半年想做什么</p></li><li><p>4.里程碑（3个月）-近3个月想做什么</p></li><li><p>5.迭代（2-4周）-近一个迭代想做什么</p></li></ul><h2 id="迭代计划"><a href="#迭代计划" class="headerlink" title="迭代计划"></a>迭代计划</h2><p>实际操作中团队基础最频繁的应该就是迭代计划，迭代计划的主要操作对象就是PB，即Product Backlog，产品待办列表。PB的产出主要基于团队承诺，PB的优先级调整就是迭代计划的主要内容。</p><p>具体操作可能分为以下几步：</p><ul><li><p>1.调整用户故事优先级</p></li><li><p>2.识别迭代目标，即团队应该共同确定一个本次迭代需要达成的目标（例如下个迭代依赖当前迭代的产出，则当前迭代必须提供）</p></li><li><p>3.根据优先级识别用户故事是否纳入本次迭代。比如严格按照优先级，团队确认当前用户故事是否可以在当前迭代完成，若可以完成则纳入本次迭代计划，否则更换一个更小的故事重复上述工作。（前提是更换不能影响当前迭代目标的达成）</p></li><li><p>4.重复上述工作，直到团队不可以再承诺任何用户故事。则迭代计划制定完成。</p></li></ul><h2 id="敏捷计划的工具"><a href="#敏捷计划的工具" class="headerlink" title="敏捷计划的工具"></a>敏捷计划的工具</h2><ul><li><p>时间盒</p></li><li><p>渐进明细</p></li><li><p>最小可售功能（MMF）</p></li><li><p>最小可用产品（MVP）</p></li><li><p>基于价值的分析</p></li><li><p>定义愿景</p></li></ul><blockquote><p>敏捷计划对应到敏捷活动中的计划会。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;适应性计划的必要性&quot;&gt;&lt;a href=&quot;#适应性计划的必要性&quot; class=&quot;headerlink&quot; title=&quot;适应性计划的必要性&quot;&gt;&lt;/a&gt;适应性计划的必要性&lt;/h2&gt;&lt;p&gt;敏捷的计划叫做适应性计划，意旨根据变化能够及时适应。为什么需要做适应性计划？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;项目的不确定性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;敏捷项目是以价值为驱动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;风险需要降低&lt;/p&gt;
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-三-打造敏捷团队</title>
    <link href="http://yoursite.com/2019/03/17/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E4%B8%89-%E6%89%93%E9%80%A0%E6%95%8F%E6%8D%B7%E5%9B%A2%E9%98%9F/"/>
    <id>http://yoursite.com/2019/03/17/我所经历的以及我所理解的敏捷-三-打造敏捷团队/</id>
    <published>2019-03-17T00:28:35.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是自组织团队？"><a href="#什么是自组织团队？" class="headerlink" title="什么是自组织团队？"></a>什么是自组织团队？</h2><p>敏捷特征适合建立自组织团队，自组织团队的特点包括：</p><ul><li><p>目标明确</p></li><li><p>公共达到目标</p></li><li><p>每个人天赋容易被激发</p><a id="more"></a><p>自组织团队的自组织并不是强调无管理，而是依赖团队形成的默认“规则”达到自管理。</p></li></ul><blockquote><p>个人体会来说，成功的敏捷团队一定是参加他们的一两次站会就能够明显感觉到与其他团队区别的。专注，有活力是我觉得最重要的两点，技术能力也很重要，但是在敏捷团队中绝对不是第一位，毕竟一般我们做的都不是什么高端项目。</p></blockquote><h2 id="如何打造自组织团队？"><a href="#如何打造自组织团队？" class="headerlink" title="如何打造自组织团队？"></a>如何打造自组织团队？</h2><p>如何打造自组织团队呢？有一些常规做法：</p><ul><li>忘记Title，接受Role</li></ul><blockquote><p>简单来说就是团队成员人人平等。建议想深入参与了解团队情况的leader能够通过参观站会，回顾会等形式介入，否则团队基本不可能实现自组织。</p></blockquote><ul><li><p>给予明确目标</p></li><li><p>反馈机制</p></li><li><p>团队协作</p></li></ul><blockquote><p>夸张地说，能两个人做的事绝对不一个人做。这样做的目的是培养团队成员的协作意识和协作能力，有见识过个人能力很强但是一旦与别人合作就不知道如何下手的“高手”,这类专家适合以外部专家或顾问的方式参与到敏捷团队的工作中。</p></blockquote><ul><li>授权：计划、估算、对项目全权负责</li></ul><blockquote><p>这一点对于PO这个角色至关重要，即使无法做到能够决定做与不做，至少在一定范围内能够决定哪个先做哪个后做。</p></blockquote><ul><li>提升团队主观能动性</li></ul><h2 id="自组织团队的规模设置"><a href="#自组织团队的规模设置" class="headerlink" title="自组织团队的规模设置"></a>自组织团队的规模设置</h2><p>建议自组织团队规模在5-9人之间，规模小到足够敏捷，同时达到能够完成复杂工作。</p><p>若少于3个人，则团队之间交付较少，生产力增长有限，且会受限于人员技能限制，导致无法正常交付增量产品。</p><p>大于9人，则沟通途径过大，沟通成本过高。</p><p>产品负责人和敏捷教练不在人数内。</p><h2 id="自组织团队的工作方式"><a href="#自组织团队的工作方式" class="headerlink" title="自组织团队的工作方式"></a>自组织团队的工作方式</h2><ul><li><p>集中办公是自组织团队的基本要求，集中办公的好处主要包括减少沟通成本，增加互动。推荐渗透式沟通，所谓渗透式沟通，通常来说就是在个人工位上吼一声，团队成员基本都是接收到你传达的信息。</p></li><li><p>在遇到冲突时自组织团队强调合作，面对，解决问题，探寻导致冲突的根源，并以合作的方式寻求解决之道，消除冲突。</p></li><li><p>参与式决策强调让更多的成员参与，更多的授权，更少的控制。</p></li><li><p>适应性领导是指在团队不同时期采取不同领导方式，例如在团队早期应该多加控制，在团队成熟之后则逐渐更多授权。</p></li></ul><blockquote><p>适应性领导在敏捷团队的5个阶段的工作</p></blockquote><table><thead><tr><th>形成</th><th>震荡</th><th>规范</th><th>成熟</th><th>解散</th></tr></thead><tbody><tr><td>直接协助，给出要求</td><td>帮助解决冲突，避免冲突升级，教练</td><td>支持者</td><td>方向引导，认可良好绩效，给予挑战</td><td>安排去处</td></tr></tbody></table><h2 id="对于分布式团队的处理"><a href="#对于分布式团队的处理" class="headerlink" title="对于分布式团队的处理"></a>对于分布式团队的处理</h2><p>非常有效的一个方式是组织面对面(face-to-face)的启动会(kick-off-meeting)，甚至有条件的话包括kick-off-events(如每个迭代开始时)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是自组织团队？&quot;&gt;&lt;a href=&quot;#什么是自组织团队？&quot; class=&quot;headerlink&quot; title=&quot;什么是自组织团队？&quot;&gt;&lt;/a&gt;什么是自组织团队？&lt;/h2&gt;&lt;p&gt;敏捷特征适合建立自组织团队，自组织团队的特点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;目标明确&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;公共达到目标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个人天赋容易被激发&lt;/p&gt;
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷-(二)-基础</title>
    <link href="http://yoursite.com/2019/03/16/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E4%BA%8C-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/03/16/我所经历的以及我所理解的敏捷-二-基础/</id>
    <published>2019-03-16T00:36:46.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="敏捷项目管理五个阶段"><a href="#敏捷项目管理五个阶段" class="headerlink" title="敏捷项目管理五个阶段"></a>敏捷项目管理五个阶段</h2><ul><li><p>构想：确定产品构想、项目目标和控制要素、项目组织以及团队如何工作</p></li><li><p>推测：制定基于性能和功能的发布计划，确保交付构想的产品</p></li><li><p>探索：在短期内计划和提供可交付的功能，不断致力于减少项目风险和不确定性</p></li><li><p>适应：审核提交的结果、当前情况以及团队绩效、必要时做出调整</p><a id="more"></a></li><li>结束：终止项目、交流主要的学习成果并庆祝</li></ul><blockquote><p>其中推测-探索-适应应该是一个不断循环的过程，对应到每次迭代的不断优化。大概场景应该是迭代开始前和客户沟通后确认迭代1的版本，迭代结束时与客户确认，将客户的反馈体现在下一个迭代中。</p></blockquote><h2 id="敏捷主要解决什么问题"><a href="#敏捷主要解决什么问题" class="headerlink" title="敏捷主要解决什么问题"></a>敏捷主要解决什么问题</h2><p>相比传统项目管理方法，敏捷更适合解决<code>复杂问题、适应多变的、未知的环境、持续交付有价值的产品、满足客户需求</code>并帮助客户建立竞争优势，从而提升企业项目、产品的投资回报。</p><blockquote><p>由此总结可以看出，实施敏捷的最终目的还是要考虑ROI，所以敏捷实施的推进有一个很重要的方法就是及时让管理层能够了解到敏捷带来的变化。其实不止是敏捷，任何工作的推进，及时通过数据报告让领导知晓成效，是这项工作能够顺利继续进行的关键。</p></blockquote><h2 id="什么时候使用敏捷"><a href="#什么时候使用敏捷" class="headerlink" title="什么时候使用敏捷"></a>什么时候使用敏捷</h2><ul><li><p>项目开始时，项目范围不能确定</p></li><li><p>项目中存在极端变化时</p></li></ul><blockquote><p>其实除了以上，还有一个很重要的前置条件是团队必须对敏捷的实施达成一致，有点类似让团队成员自己做出承诺的意思，这样敏捷实施才不会无疾而终。</p></blockquote><h2 id="敏捷软件开发宣言"><a href="#敏捷软件开发宣言" class="headerlink" title="敏捷软件开发宣言"></a>敏捷软件开发宣言</h2><p>我们一直在实践中探寻<code>更好</code>的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p><ul><li><p>个体和互动高于流程和工具</p></li><li><p>可用的软件高于详尽的文档</p></li><li><p>客户合作高于合同谈判</p></li><li><p>响应变化高于遵循计划</p></li></ul><blockquote><p>通常说到敏捷宣言会漏掉开头一句，实际敏捷并没有否定其他软件开发方法，敏捷也有其特殊的使用场景。对于一些精密度要求特别高，结果要求特别严格的项目（记得当时老师举的是军工行业），敏捷就不一定适用。敏捷宣言除了第一句是谈论工作方式，其他后三句其实都是在强调价值，就是敏捷的最终目的其实就是让客户心甘情愿地掏钱。</p></blockquote><h2 id="敏捷原则12条"><a href="#敏捷原则12条" class="headerlink" title="敏捷原则12条"></a>敏捷原则12条</h2><ul><li><p>我们最重要的目标，是通过持续不断地尽早交付有价值的软件使客户满意。</p></li><li><p>欣然面对需求变更，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。</p></li><li><p>经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。</p></li><li><p>业务人员和开发人员必须相互合作，一起工作，项目中的每一天都不例外。</p></li><li><p>激发个人的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</p></li><li><p>不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。</p></li><li><p>可工作的软件是进度的首要度量标准。</p></li><li><p>敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。</p></li><li><p>坚持不懈地追求技术卓越和良好设计。敏捷能力由此增强。</p></li><li><p>以简洁为本，它是极力减少不必要工作量的艺术。</p></li><li><p>最好的架构、需求和设计出自自组织团队。</p></li><li><p>团队定期的反思如何能够提高成效，并以此调整自身的举止表现。</p></li></ul><blockquote><p>关于需求变更应该有流程控制，保障PO的权限。实际这一点很难做到，毕竟实际大部分开发工作就是采用的BDD（Boss Driver Development）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;敏捷项目管理五个阶段&quot;&gt;&lt;a href=&quot;#敏捷项目管理五个阶段&quot; class=&quot;headerlink&quot; title=&quot;敏捷项目管理五个阶段&quot;&gt;&lt;/a&gt;敏捷项目管理五个阶段&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构想：确定产品构想、项目目标和控制要素、项目组织以及团队如何工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;推测：制定基于性能和功能的发布计划，确保交付构想的产品&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;探索：在短期内计划和提供可交付的功能，不断致力于减少项目风险和不确定性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;适应：审核提交的结果、当前情况以及团队绩效、必要时做出调整&lt;/p&gt;
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>我所经历的以及我所理解的敏捷(一)-开篇</title>
    <link href="http://yoursite.com/2019/03/15/%E6%88%91%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E6%95%8F%E6%8D%B7-%E4%B8%80-%E5%BC%80%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/15/我所经历的以及我所理解的敏捷-一-开篇/</id>
    <published>2019-03-15T00:36:20.000Z</published>
    <updated>2019-07-29T07:37:32.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>换了新东家以来，由于研发模式的差异，对在上一个东家涉及的一些知识暂时无实践机会，其中觉得最遗憾的应该是敏捷相关的知识体系和实践经历。得益于上个东家的信任，有幸参与过公司敏捷团队的教练工作，同时也在公司的安排下参与了ACP培训，这个培训至今仍然是我觉得最有价值的一次培训，虽然涉及技术内容不多，但是却通过敏捷这一条线将自己所涉及的一些技术串联起来。在这一系列学习和实践中，也结合敏捷的思想有一些自己的感悟。在这记录下来，以便后面回过头来参考。其中会大量参考ACP培训的内容，也算是一个学习总结。</p><h2 id="敏捷出现的背景"><a href="#敏捷出现的背景" class="headerlink" title="敏捷出现的背景"></a>敏捷出现的背景</h2><p>从软件作坊到软件危机，再到软件工程，传统的软件工程理论使得软件系统的开发流程变得越来越复杂，导致：</p><ul><li>过长的开发周期<a id="more"></a></li><li><p>无法应对迅速变化的市场环境，需求很难修改</p></li><li><p>超预算开发</p></li><li><p>项目进度检查困难</p></li><li><p>最终交付的软件，不一定能满足用户需求</p></li><li><p>人员流动频繁，官僚制度严重</p></li></ul><p>实际操作时可能遇到的问题：</p><ul><li><p>一方面市场的需求瞬息万变，很难实现产品需求的明确且完整地收集</p></li><li><p>一方面技术的发展也日新月异，对于所定义的功能的可实现性也面临着多重不确定性的因素</p></li></ul><p>传统的研发模式中，比较常见的就是长期性计划，例如一个项目可能持续半年，项目管理者需要提前将这半年可能发生的所有异常情况都考虑完全，从而制定细致周到的项目计划。不管用哪想这都是不可能的。</p><p>有道是人算不如天算，过一天算一天似乎更合适。当然这是个夸张的说法,本质上的意思是应该做短期计划，并且不断根据实际情况调整。</p><h2 id="敏捷是什么"><a href="#敏捷是什么" class="headerlink" title="敏捷是什么"></a>敏捷是什么</h2><ul><li><p>敏捷不是一个流程或方法</p></li><li><p>敏捷不是一套固定模板</p></li><li><p>敏捷不是一种可以直接重用的方法</p></li></ul><blockquote><p>敏捷是一种为了适应不断变化的需求，以人为核心，通过迭代增量等方式的开发方法。其本质是一种实践。</p></blockquote><p>曾和同事交流说敏捷和Scrum，XP的关系，个人理解敏捷是一种思想，而Scrum，XP这些是在敏捷思想指导下总结出现的实践。</p><h2 id="敏捷的三根支柱"><a href="#敏捷的三根支柱" class="headerlink" title="敏捷的三根支柱"></a>敏捷的三根支柱</h2><p>敏捷是基于<code>经验型</code>的方法，并不依赖于<code>预测</code>，其成功依赖于三根支柱：</p><ul><li><p>透明性：信息透明</p></li><li><p>经常性检查：获得反馈</p></li><li><p>适应：根据反馈快速调整并做出改变</p></li></ul><p>三大支柱在敏捷实践的活动中都会有体现，所有活动的开展都应该围绕这三大原则。</p><h2 id="瀑布VS敏捷"><a href="#瀑布VS敏捷" class="headerlink" title="瀑布VS敏捷"></a>瀑布VS敏捷</h2><table><thead><tr><th></th><th>传统项目管理</th><th>敏捷项目管理</th></tr></thead><tbody><tr><td>流程</td><td>顺序、线性</td><td>迭代、并行</td></tr><tr><td>需求与范围</td><td>相对明确</td><td>随时变化 </td></tr><tr><td>计划</td><td>完善的计划</td><td>渐进明细 </td></tr><tr><td>流程文档</td><td>详尽的</td><td>足够的</td></tr><tr><td>交付</td><td>一次性交付</td><td>持续性交付 </td></tr><tr><td>管理风格</td><td>领导式</td><td>仆人式 </td></tr></tbody></table><p>实际上大部分项目都会是传统型和敏捷型混合，比如研发人员吐槽最多的需求的不断变化，在传统型项目中出现也比较频繁。</p><h2 id="敏捷与其他技术实践的关系"><a href="#敏捷与其他技术实践的关系" class="headerlink" title="敏捷与其他技术实践的关系"></a>敏捷与其他技术实践的关系</h2><p>可能存在的乱象是将敏捷与其他技术实践完全隔离，例如一些企业会强调要做持续集成，持续交付，DevOps等等实践，但是却不把敏捷的实施作为第一步，同理还包括自动化测试。</p><p>当然并非是不做敏捷这些实践就无法实施，比如自动化测试，即使是在传统的研发模式中仍然有其用武之地。但是就如每个人都在寻找各自的真命天子(女)一样，敏捷就如这些实践的真命天子(女)，只有在敏捷的研发模式中，这些实践才能更好的发挥其威力。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;换了新东家以来，由于研发模式的差异，对在上一个东家涉及的一些知识暂时无实践机会，其中觉得最遗憾的应该是敏捷相关的知识体系和实践经历。得益于上个东家的信任，有幸参与过公司敏捷团队的教练工作，同时也在公司的安排下参与了ACP培训，这个培训至今仍然是我觉得最有价值的一次培训，虽然涉及技术内容不多，但是却通过敏捷这一条线将自己所涉及的一些技术串联起来。在这一系列学习和实践中，也结合敏捷的思想有一些自己的感悟。在这记录下来，以便后面回过头来参考。其中会大量参考ACP培训的内容，也算是一个学习总结。&lt;/p&gt;
&lt;h2 id=&quot;敏捷出现的背景&quot;&gt;&lt;a href=&quot;#敏捷出现的背景&quot; class=&quot;headerlink&quot; title=&quot;敏捷出现的背景&quot;&gt;&lt;/a&gt;敏捷出现的背景&lt;/h2&gt;&lt;p&gt;从软件作坊到软件危机，再到软件工程，传统的软件工程理论使得软件系统的开发流程变得越来越复杂，导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过长的开发周期
    
    </summary>
    
    
      <category term="敏捷" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>一些感想</title>
    <link href="http://yoursite.com/2019/01/17/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"/>
    <id>http://yoursite.com/2019/01/17/一些感想/</id>
    <published>2019-01-17T09:08:51.000Z</published>
    <updated>2019-07-29T07:28:54.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ul><li><p>对应开发人员能力不够理想的情况下，自动化测试更凸显其价值。</p></li><li><p>端到端的自动化测试是下下策，不管是服务拆分还是前后端分离，目标都是把测试目标缩小。</p></li><li><p>前后端分离之后的前端自动化，可以考虑以图像对比技术为主。</p></li><li><p>应该开发或者寻找一种技术方案能够快速通过录制回放方式生成一整套后端mock接口，用于前端自动化测试。</p></li><li><p>数据多了之后才体会到”数字化研发”的含义，数据的意义不仅仅是用于考核，还包括方向引导，决策参考等等。</p></li><li><p>入职新公司之后先后引入了基于python，基于TypeScript,基于Node，基于JavaScript的各种开源项目，并在上面做了少量二次开发，优秀的开源项目确实让二次开发变得简单，语言完全不是障碍。</p></li><li><p>对任何技术都心存敬畏之心很多人都做不到，但得时刻提醒自己尽量做到。</p></li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li><p>重要的人越来越重要。</p></li><li><p>为人父母之后内心柔软很多，同时也发现情绪管理能力太差。</p></li><li><p>坚持阅读，尽量让眼界不一样。</p></li><li><p>期待晚年的“二人世界”，哈哈。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对应开发人员能力不够理想的情况下，自动化测试更凸显其价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;端到端的自动化测试是下下策，
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Superset提示`fetch data error`</title>
    <link href="http://yoursite.com/2018/12/24/Superset%E6%8F%90%E7%A4%BA%60fetch%20data%20error%60/"/>
    <id>http://yoursite.com/2018/12/24/Superset提示`fetch data error`/</id>
    <published>2018-12-24T00:35:54.000Z</published>
    <updated>2019-07-29T07:28:54.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>为了应付各种汇报和考核需要，引入轻量级BI工具生成各个维护的视图，在工具选型阶段简单调研了<code>Metabase</code>,<code>Superset</code>以及<code>Knowage</code>(也就是Spago BI)，最后选择<code>Superset</code>是因为自带图表比<code>Metabase</code>酷炫且比<code>Knowage</code>轻量，足以满足当前需求。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于对数据库不够熟悉，可能是设计不足，数据量大了之后查询结果返回时间过长，导致在视图生成时提示<code>fetch data error</code>,查看后台提示发现是因为查询时间超出了<code>60s</code>的默认超时控制。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>尝试过通过<code>superset_config.py</code>启动时注入环境变量无效，因此查看镜像的<code>Dockerfile</code>，发现环境变量在其中定义，因此修改重新制作镜像解决，<code>Dockerfile</code>内容如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FROM amancevice/superset</div><div class="line"></div><div class="line">MAINTAINER Angrytester &lt;thx_phila@yahoo.com&gt;</div><div class="line"></div><div class="line">ENV GUNICORN_TIMEOUT 3600 </div><div class="line">ENV GUNICORN_WORKERS 4</div><div class="line"></div><div class="line">ENV GUNICORN_CMD_ARGS=&quot;--workers $&#123;GUNICORN_WORKERS&#125; --timeout $&#123;GUNICORN_TIMEOUT&#125; --bind $&#123;GUNICORN_BIND&#125; --limit-request-line $&#123;GUNICORN_LIMIT_REQUEST_LINE&#125; --limit-request-field_size $&#123;GUNICORN_LIMIT_REQUEST_FIELD_SIZE&#125;&quot;</div><div class="line"></div><div class="line"></div><div class="line"># Deploy application</div><div class="line">EXPOSE 8088</div><div class="line">HEALTHCHECK CMD [&quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8088/health&quot;]</div><div class="line">CMD [&quot;gunicorn&quot;, &quot;superset:app&quot;]</div><div class="line">USER superset</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;为了应付各种汇报和考核需要，引入轻量级BI工具生成各个维护的视图，在工具选型阶段简单调研了&lt;code&gt;Metabase&lt;/code&gt;,&lt;code&gt;Superset&lt;/code&gt;以及&lt;code&gt;Knowage&lt;/code&gt;(也就是Spago BI)，最后选择&lt;code&gt;Superset&lt;/code&gt;是因为自带图表比&lt;code&gt;Metabase&lt;/code&gt;酷炫且比&lt;code&gt;Knowage&lt;/code&gt;轻量，足以满足当前需求。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;由于对数据库不够熟悉，可能是设计不足，数据量大了之后查询结果返回时间过长，导致在视图生成时提示&lt;code&gt;fetch data error&lt;/code&gt;,查看后台提示发现是因为查询时间超出了&lt;code&gt;60s&lt;/code&gt;的默认超时控制。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;尝试过通过&lt;code&gt;superset_config.py&lt;/code&gt;启动时注入环境变量无效，因此查看镜像的&lt;code&gt;Dockerfile&lt;/code&gt;，发现环境变量在其中定义，因此修改重新制作镜像解决，&lt;code&gt;Dockerfile&lt;/code&gt;内容如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="Superset" scheme="http://yoursite.com/tags/Superset/"/>
    
  </entry>
  
  <entry>
    <title>低侵入配置Gradle项目获取单元测试结果</title>
    <link href="http://yoursite.com/2018/12/17/%E4%BD%8E%E4%BE%B5%E5%85%A5%E9%85%8D%E7%BD%AEGradle%E9%A1%B9%E7%9B%AE%E8%8E%B7%E5%8F%96%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/12/17/低侵入配置Gradle项目获取单元测试结果/</id>
    <published>2018-12-17T10:47:41.000Z</published>
    <updated>2019-07-29T07:28:54.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>目前公司CI采用的是基于<code>Drone CI</code>的方案，Pipeline的各个Job主要依靠各种Docker镜像支撑。例如拉取代码使用的是官方的插件镜像，编译代码采用在官方镜像基础上的定制镜像等等。随着集团对于代码质量的要求越来越高，对于早该纳入持续集成体系的单元测试工作终于提上了议程。</p><h3 id="工作目标"><a href="#工作目标" class="headerlink" title="工作目标"></a>工作目标</h3><p>第一步的工作目标是在<code>尽量少侵入各产品线当前正常研发工作的前提下</code>将单元测试的Job集成进当前的持续集成体系中，并能成功收集当前所有后端系统的单元测试现状，后续再根据现状制定相关指标提升计划。</p><h3 id="工作难点"><a href="#工作难点" class="headerlink" title="工作难点"></a>工作难点</h3><p>公司后端系统大都采用的Java，构建工具统一使用Gradle。市场上对于配置Gradle获取单元测试相关结果的方案已经很成熟了，因此配置并不是这项工作的难点。难点在于工作前提-<code>尽量少侵入各产品线当前正常研发工作的前提下</code>。现有方案大都需要修改项目的<code>build.gradle</code>文件以添加各种插件依赖和task，虽然知道其中原理的我们清楚这并不会对项目自身产生任何影响，但是无奈要求来自于高层，作为严格遵循BDD(Boss Driven Development)的我们来说，必须考虑实现。</p><h2 id="工作思路"><a href="#工作思路" class="headerlink" title="工作思路"></a>工作思路</h2><a id="more"></a><h3 id="主体方案"><a href="#主体方案" class="headerlink" title="主体方案"></a>主体方案</h3><p>方案仍然选择通用的Jacoco+SonarQube，其中Jacoco用于收集单元测试的代码覆盖率，SonarQube用于展现单元测试相关结果，包括单元测试个数，成功率，覆盖率等。</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>不对项目代码有任何侵入，唯一可入手的地方就是持续集成编排文件(.drone.yml)和CI中用到的各种镜像了。考虑易用性，最佳入手点当然就是镜像了。理想效果是在单元测试Job中引用我提供的镜像，执行一行命令即可完成单元测试执行和单元测试结果收集的工作。</p><p>镜像需要完成的工作包括处理Jacoco和SonarQube的Task所需要的依赖以及Task的相关配置，有一种比较笨的方案是在Job执行到单元测试之后，通过封装的shell脚本修改项目的<code>build.gradle</code>文件，手动加入相关依赖和Task配置，执行结束之后再恢复。这种方案的处理相对复杂，且如果操作不当，很有可能影响到后续Job的执行。因此我们采取了另外一种方案，通过父子项目传递依赖。通过创建一个虚拟的父项目，在父项目的配置文件中加入相关依赖和Task配置，然后将相关配置传递到作为子项目的真正项目。</p><h3 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h3><p>我们以<code>gradle</code>的镜像作为基底镜像，创建了一个虚拟的gradle项目-cov，这个项目只包含两个文件：<code>build.gradle</code>和<code>settings.gradle</code>。</p><p><code>build.gradle</code>的内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.6.2"</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">subprojects&#123;</div><div class="line"></div><div class="line">  apply plugin: 'java'</div><div class="line">  apply plugin: 'jacoco'</div><div class="line">  apply plugin: 'org.sonarqube'</div><div class="line"></div><div class="line">  jacoco &#123;</div><div class="line">    toolVersion = "0.7.9"</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jacocoTestReport &#123;</div><div class="line">      reports &#123;</div><div class="line">          xml.enabled false</div><div class="line">          html.enabled true</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  check.dependsOn jacocoTestReport</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>settings.gradle</code>的内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rootProject.name = 'cov'</div><div class="line">include 'unit-test-sample'</div></pre></td></tr></table></figure><p>然后再封装shell脚本实现自动执行单元测试和收集单元测试结果。</p><p>shell脚本内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 退回上一级目录方便做mv</span></div><div class="line">cd ..</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 将当前项目移动至/cov</span></div><div class="line">mkdir -p /cov/$&#123;DRONE_REPO_NAME&#125;</div><div class="line">cp -r $&#123;DRONE_REPO_NAME&#125;/* /cov/$&#123;DRONE_REPO_NAME&#125;</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 替换处理cov下settings.gradle</span></div><div class="line">sed -i "s/unit-test-sample/$&#123;DRONE_REPO_NAME&#125;/g" /cov/settings.gradle</div><div class="line"></div><div class="line">sonar_url=http://localhost:9000/sonar</div><div class="line">projectName=$&#123;DRONE_REPO_NAME&#125;</div><div class="line">projectKey=$&#123;DRONE_REPO//\//\:&#125;</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span>到cov目录做后续操作</span></div><div class="line">cd /cov</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 单元测试失败暂时不做拦截，单独执行</span></div><div class="line">gradle test || true</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 单元测试执行单独执行sonar，否则由于sonar依赖<span class="built_in">test</span>，<span class="built_in">test</span>失败无法执行</span></div><div class="line">gradle sonarqube -x test -Dsonar.host.url=$sonar_url -Dsonar.projectKey=$projectKey -Dsonar.projectName=$projectName</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">获取componentId</span></div><div class="line">curl -s $sonar_url/api/components/show?key=$projectKey &gt; component.json</div><div class="line">componentId=$(jq .component.id component.json | sed 's/\"//g')</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">等待当前项目无<span class="keyword">in</span> progress任务</span></div><div class="line">while [[ $QUEUE != [] ]]</div><div class="line">do</div><div class="line">curl -s $sonar_url/api/ce/component?componentId=$componentId &gt; task.json</div><div class="line">QUEUE=$(jq .queue task.json)</div><div class="line">echo "等待Sonar解析任务完成..."</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 保存覆盖率数据</span></div><div class="line">curl -i -H 'Content-type:application/json' -X POST -d "&#123;\"drone_repo\":\"$&#123;DRONE_REPO&#125;\",\"drone_commit\":\"$&#123;DRONE_COMMIT&#125;\",\"drone_tag\":\"$&#123;DRONE_TAG&#125;\",\"component_key\":\"$projectKey\"&#125;" http://localhost:8080/codequalitydata</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">获取qualitygateStatus</span></div><div class="line">curl -s $sonar_url/api/qualitygates/project_status?projectKey=$projectKey &gt; qualitygate.json</div><div class="line">qualitygateStatus=$(jq .projectStatus.status qualitygate.json | sed 's/\"//g')</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">判断如果qualitygateStatus不为OK，则终止</span></div><div class="line">if [[ $qualitygateStatus != OK ]]</div><div class="line">then</div><div class="line">echo "$&#123;projectName&#125;单元测试不达标，请查看Sonar结果详情！$sonar_url/dashboard?id=$projectKey"</div><div class="line"><span class="meta">#</span><span class="bash"> 暂时不拦截，直接通过，拦截则退出码改成1</span></div><div class="line">exit 0</div><div class="line">else</div><div class="line">echo "质量门通过"</div><div class="line">fi</div></pre></td></tr></table></figure><p>这个脚本主要完成了以下几项工作：</p><ul><li><p>将当前项目复制到我们创建的虚拟父项目cov下。（不能剪切，这里与drone的执行机制有关，所有Job操作的是同一个工作空间，如果剪切则下一个Job将访问不到任何项目内容）</p></li><li><p>替换父项目中的<code>settings.gradle</code>文件中的include的内容，将当前项目设置为子项目。</p></li><li><p>通过drone内置的环境变量设置<code>projectKey</code>和<code>projectName</code>，其中<code>projectKey</code>采用包含group的仓库完整路径，斜杠用冒号替换。</p></li><li><p>在虚拟父项目cov下执行单元测试，由于第一阶段目标不对CI流程做阻断，添加设置<code>|| true</code>继续永远往下执行。</p></li><li><p>执行完单元测试后执行<code>sonarqube</code>，要注意<code>sonarqube</code>默认依赖<code>test</code>，因此需要通过<code>-x test</code>排除，并将上面设置的<code>projectKey</code>和<code>projectName</code>传入命令行。</p></li><li><p>由于sonar解析单元测试结果需要一定时间，为了获取准确结果，通过等待不存在解析中任务来判断sonar执行完成，再获取质量门状态。</p></li><li><p>由于sonar上不会按照CI的执行保存每次的单元测试结果，为了满足这一需求，我们自定义了一个外部存储接口，在sonar执行完成后自动收集单元测试相关结果入数据库。</p></li></ul><h3 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h3><p>镜像制作相对简单，基底镜像采用<code>gradle</code>,将虚拟父项目<code>cov</code>和shell脚本加入镜像中。</p><p><code>Dockerfile</code>内容参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">FROM gradle:4.7</div><div class="line"></div><div class="line">MAINTAINER AngryTester &lt;thx_phila@yahoo.com&gt;</div><div class="line"></div><div class="line">USER root</div><div class="line"></div><div class="line">COPY check.sh /</div><div class="line"></div><div class="line">COPY jq /</div><div class="line"></div><div class="line">WORKDIR /</div><div class="line"></div><div class="line">RUN mv check.sh /usr/local/bin/check \</div><div class="line">&amp;&amp; mv jq /usr/local/bin/jq \</div><div class="line">&amp;&amp; chmod +x /usr/local/bin/check \</div><div class="line">&amp;&amp; chmod +x /usr/local/bin/jq</div><div class="line"></div><div class="line">COPY cov /cov</div></pre></td></tr></table></figure><p><strong><em>因为shell脚本中用到jq工具，因此还需要将jq工具加入镜像中。</em></strong></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>拉取镜像并执行封装的shell即可。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>该方案虽然解决了侵入性的问题，同时也带来局限性，例如对于自身为多模块的项目无法级联传递。仅供参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;目前公司CI采用的是基于&lt;code&gt;Drone CI&lt;/code&gt;的方案，Pipeline的各个Job主要依靠各种Docker镜像支撑。例如拉取代码使用的是官方的插件镜像，编译代码采用在官方镜像基础上的定制镜像等等。随着集团对于代码质量的要求越来越高，对于早该纳入持续集成体系的单元测试工作终于提上了议程。&lt;/p&gt;
&lt;h3 id=&quot;工作目标&quot;&gt;&lt;a href=&quot;#工作目标&quot; class=&quot;headerlink&quot; title=&quot;工作目标&quot;&gt;&lt;/a&gt;工作目标&lt;/h3&gt;&lt;p&gt;第一步的工作目标是在&lt;code&gt;尽量少侵入各产品线当前正常研发工作的前提下&lt;/code&gt;将单元测试的Job集成进当前的持续集成体系中，并能成功收集当前所有后端系统的单元测试现状，后续再根据现状制定相关指标提升计划。&lt;/p&gt;
&lt;h3 id=&quot;工作难点&quot;&gt;&lt;a href=&quot;#工作难点&quot; class=&quot;headerlink&quot; title=&quot;工作难点&quot;&gt;&lt;/a&gt;工作难点&lt;/h3&gt;&lt;p&gt;公司后端系统大都采用的Java，构建工具统一使用Gradle。市场上对于配置Gradle获取单元测试相关结果的方案已经很成熟了，因此配置并不是这项工作的难点。难点在于工作前提-&lt;code&gt;尽量少侵入各产品线当前正常研发工作的前提下&lt;/code&gt;。现有方案大都需要修改项目的&lt;code&gt;build.gradle&lt;/code&gt;文件以添加各种插件依赖和task，虽然知道其中原理的我们清楚这并不会对项目自身产生任何影响，但是无奈要求来自于高层，作为严格遵循BDD(Boss Driven Development)的我们来说，必须考虑实现。&lt;/p&gt;
&lt;h2 id=&quot;工作思路&quot;&gt;&lt;a href=&quot;#工作思路&quot; class=&quot;headerlink&quot; title=&quot;工作思路&quot;&gt;&lt;/a&gt;工作思路&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>前端自动化测试中如何平衡稳定性和效率</title>
    <link href="http://yoursite.com/2018/12/13/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B9%B3%E8%A1%A1%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E6%95%88%E7%8E%87/"/>
    <id>http://yoursite.com/2018/12/13/前端自动化测试中如何平衡稳定性和效率/</id>
    <published>2018-12-13T01:04:08.000Z</published>
    <updated>2019-07-29T07:28:54.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同场景下的前端自动化测试要点以及策略选择"><a href="#不同场景下的前端自动化测试要点以及策略选择" class="headerlink" title="不同场景下的前端自动化测试要点以及策略选择"></a>不同场景下的前端自动化测试要点以及策略选择</h2><p>前端自动化测试的应用场景众多，常见的包括自动化冒烟，自动化回归，版本自动化测试以及环境的自动巡检。对于自动化冒烟来说，效率可能需要排在第一位，因为往往自动化冒烟都是集成在pipeline中，pipeline中的节点众多，自动化冒烟很容易成为整条pipeline的运行瓶颈（运行时间过长）。对于自动化回归，版本测试以及环境的自动巡检来说，效率可能并不是第一位，因为往往这部分自动化测试要求的时效性并不高，以自动化回归为例，通常我们会找一台独立的服务器运行，不会影响到测试人员手中的正常工作，主要消耗的是机器资源。</p><p>对于策略选择，自动化冒烟以效率为先，因此在自动化冒烟测试的用例选择中需要非常谨慎，对于一些测试预期结果不可控的用例尽量不要加在自动化冒烟测试用例库中，而对于自动化回归，版本测试等使用场景，用例的选择则可以稍微粗放一些，只要选择的自动化测试框架能够帮助我们快速的排错，那么在时间允许的情况下，应该尽可能运行所有的自动化测试用例。环境巡检属于比较特殊的使用场景，稳定性肯定第一位，因为谁都接受不了一堆的误报。而如果效率过低，对于快速发现问题不利，特别对于生产环境的巡检来说，效率的要求也极高，因此对于这种场景，我们应该采取特殊策略对待，尽量在高稳定性的同时保障高效率。</p><h2 id="常见的可能影响稳定性和效率的因素"><a href="#常见的可能影响稳定性和效率的因素" class="headerlink" title="常见的可能影响稳定性和效率的因素"></a>常见的可能影响稳定性和效率的因素</h2><p>稳定性和效率往往是相悖的，为了解决稳定性的问题，往往就会牺牲效率。最常见的，不确定元素多久才会出现，则在脚本中加入足够长的绝对等待，这对于效率的影响是非常大。还有在前端自动化测试的元素定位上，在自动化测试设计时往往图方便，会直接用浏览器的插件完成元素的定位信息的提取，通常是xpath，这样对于当前的自动化测试实施确实节约了时间，但是xpath的维护性非常差，一个层级的变动可能影响整个定位信息失效，这对于维护的工作量是致命的。还有一些常见的在前端自动化测试中可能影响到脚本运行的原因，例如服务器上的其他服务影响到浏览器的运行，导致运行失败等。</p><h2 id="提升前端自动化测试稳定性和效率的常用技巧"><a href="#提升前端自动化测试稳定性和效率的常用技巧" class="headerlink" title="提升前端自动化测试稳定性和效率的常用技巧"></a>提升前端自动化测试稳定性和效率的常用技巧</h2><h3 id="减少服务器上其他服务对浏览器的影响"><a href="#减少服务器上其他服务对浏览器的影响" class="headerlink" title="减少服务器上其他服务对浏览器的影响"></a>减少服务器上其他服务对浏览器的影响</h3><p>针对这点有三种方案，第一种也是最简单的就是准备一台专门用于你这一个项目的前端自动化测试运行的服务器，不允许运行其他项目；第二种是用docker容器来代替运行服务器，例如常见的selenium grid+docker的方案，容器是一个独立的进程，服务器上的各个进程间都是隔离的，不存在互相影响的情况；第三种是使用无头浏览器。<br>第一种方案无需介绍，重点介绍第二种和第三种方案：</p><p>RF应用selenium grid+docker启动浏览器的关键脚本如下：</p><p><img src="/assets/grid.png" alt=""></p><p>即在open browser关键字的第四个参数输入grid_hub服务地址即可，目前部门已经提供了两个hub可供使用：</p><p>RF应用无头浏览器的关键脚本如下：</p><p><img src="/assets/headless.png" alt=""></p><p>核心脚本为第二行在chrome的启动参数中加上–headless</p><h3 id="对于不确定弹框的捕获"><a href="#对于不确定弹框的捕获" class="headerlink" title="对于不确定弹框的捕获"></a>对于不确定弹框的捕获</h3><p>所谓不确定弹框，不是指由于环境异常导致的各种弹框（例如网络连接中断，服务器异常等），而是指在不同合理的外部条件下出现的弹框，例如在网速慢的时候，可能会出现的缓冲图标。针对弹框内容的捕获，由于网络条件的不确定性，往往很难捕捉。这个时候就可以借助抓包利器-fiddler。fiddler的rule中设置请求断点，一条一条的发送请求。</p><p><img src="/assets/fiddler.png" alt=""></p><p>待获取到弹框内容后，再取消断点设置。</p><h3 id="对于等待时间的处理"><a href="#对于等待时间的处理" class="headerlink" title="对于等待时间的处理"></a>对于等待时间的处理</h3><p>不建议绝对等待，只建议相对等待。所以的相对等待是基于某个条件来做等待时间的设置，常见的关键字有：wait until系列。</p><h3 id="对于不确定是否出现的元素的处理"><a href="#对于不确定是否出现的元素的处理" class="headerlink" title="对于不确定是否出现的元素的处理"></a>对于不确定是否出现的元素的处理</h3><p>对于不确定是否会出现的元素，可以增加一个前置关键字先判断是否存在，然后再决定是否对这个元素进行处理，例如不确定是否会出现的缓冲图标，可以先定义一个关键字获取元素是否存在：</p><p><img src="/assets/keyword.png" alt=""></p><p>然后再在脚本中调用这个关键字先获取是否存在，再决定是否对元素进行处理：</p><p><img src="/assets/loading.png" alt=""></p><p>核心关键字是Run Keyword And Return Status和Run Keyword If。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不同场景下的前端自动化测试要点以及策略选择&quot;&gt;&lt;a href=&quot;#不同场景下的前端自动化测试要点以及策略选择&quot; class=&quot;headerlink&quot; title=&quot;不同场景下的前端自动化测试要点以及策略选择&quot;&gt;&lt;/a&gt;不同场景下的前端自动化测试要点以及策略选择&lt;/
      
    
    </summary>
    
    
      <category term="RobotFramework" scheme="http://yoursite.com/tags/RobotFramework/"/>
    
  </entry>
  
  <entry>
    <title>RobotFramework接口测试设置代理</title>
    <link href="http://yoursite.com/2018/12/12/RobotFramework%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/12/RobotFramework接口测试设置代理/</id>
    <published>2018-12-12T11:08:10.000Z</published>
    <updated>2019-07-29T07:28:54.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>使用RobotFramework+Selenium2Library进行UI自动化测试时，启动的浏览器实例会直接使用在IE中设置的代理，但是接口测试时调用的<code>robotframework-requests</code>不会直接调用浏览器代理，因此需要在测试脚本中设置。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>脚本片段如下:</p><table><thead><tr><th>${proxies}</th><th>Create Dictionary</th><th>http=<a href="http://172.26.1.1:8080" target="_blank" rel="external">http://172.26.1.1:8080</a></th><th>https=<a href="http://172.26.1.1:8080" target="_blank" rel="external">http://172.26.1.1:8080</a></th></tr></thead><tbody><tr><td>Create Session</td><td>api</td><td>${domain}</td><td>cookies=${cookies}</td><td>proxies=${proxies}</td></tr></tbody></table><h2 id="代理需认证的处理"><a href="#代理需认证的处理" class="headerlink" title="代理需认证的处理"></a>代理需认证的处理</h2><a id="more"></a><p>遇到代理服务器需要认证的情况，需要在代理地址中加上用户名密码，例如用户名为<code>user</code>,密码为<code>pass</code>，则代理地址为：<code>http://user:pass@172.26.1.1:8080</code>。</p><h3 id="特殊情况：用户名密码中包含特殊字符"><a href="#特殊情况：用户名密码中包含特殊字符" class="headerlink" title="特殊情况：用户名密码中包含特殊字符"></a>特殊情况：用户名密码中包含特殊字符</h3><p>例如密码包含<code>!@#</code>等特殊时，则需要将特殊字符转化为ASCII码，对应表为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">~ : 0x7E,         ! : 0x21    </div><div class="line">@ : 0x40,         # : 0x23  </div><div class="line">$ : 0x24,         % : 0x25  </div><div class="line">^ : 0x5E,         &amp; : 0x26  </div><div class="line">* : 0x2A,         ? : 0x3F</div></pre></td></tr></table></figure><p>若密码为<code>pass！@#</code>,则输入时应该调整为<code>pass%21%40%23</code>,即<code>0x</code>用<code>%</code>代替。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;使用RobotFramework+Selenium2Library进行UI自动化测试时，启动的浏览器实例会直接使用在IE中设置的代理，但是接口测试时调用的&lt;code&gt;robotframework-requests&lt;/code&gt;不会直接调用浏览器代理，因此需要在测试脚本中设置。&lt;/p&gt;
&lt;h2 id=&quot;设置方法&quot;&gt;&lt;a href=&quot;#设置方法&quot; class=&quot;headerlink&quot; title=&quot;设置方法&quot;&gt;&lt;/a&gt;设置方法&lt;/h2&gt;&lt;p&gt;脚本片段如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;${proxies}&lt;/th&gt;
&lt;th&gt;Create Dictionary&lt;/th&gt;
&lt;th&gt;http=&lt;a href=&quot;http://172.26.1.1:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://172.26.1.1:8080&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;https=&lt;a href=&quot;http://172.26.1.1:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://172.26.1.1:8080&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Create Session&lt;/td&gt;
&lt;td&gt;api&lt;/td&gt;
&lt;td&gt;${domain}&lt;/td&gt;
&lt;td&gt;cookies=${cookies}&lt;/td&gt;
&lt;td&gt;proxies=${proxies}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;代理需认证的处理&quot;&gt;&lt;a href=&quot;#代理需认证的处理&quot; class=&quot;headerlink&quot; title=&quot;代理需认证的处理&quot;&gt;&lt;/a&gt;代理需认证的处理&lt;/h2&gt;
    
    </summary>
    
    
      <category term="RobotFramework" scheme="http://yoursite.com/tags/RobotFramework/"/>
    
      <category term="Proxy" scheme="http://yoursite.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>Java Web项目集成Jetty</title>
    <link href="http://yoursite.com/2018/07/03/Java-Web%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Jetty/"/>
    <id>http://yoursite.com/2018/07/03/Java-Web项目集成Jetty/</id>
    <published>2018-07-03T06:02:34.000Z</published>
    <updated>2019-07-29T07:28:54.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>最近花好多时间在<a href="https://github.com/aharin/inproctester" target="_blank" rel="external">inproctester</a>这个项目上,暂时还是没有很大的进展，挫败感强烈。虽然进展不多，但过程中还是接触了一些网上貌似不太好查到的新东西，记录一下不枉费这段时间的心血。</p><h2 id="Jetty是什么"><a href="#Jetty是什么" class="headerlink" title="Jetty是什么"></a>Jetty是什么</h2><p>可以内嵌到应用里的中间件，作用与<code>tomcat</code>或<code>jboss</code>类似，优点是不需要安装，可直接通过代码内嵌进应用，然后直接和直接应用程序一样执行。</p><h2 id="配置过程中可能存在的问题"><a href="#配置过程中可能存在的问题" class="headerlink" title="配置过程中可能存在的问题"></a>配置过程中可能存在的问题</h2><ul><li><p>Jetty对EL表达式的支持不好，导致页面报500无法访问，主要是针对EL表达式中的三目运算符，冒号前后的选项必须空格。</p></li><li><p>Jetty运行应用时，通过<code>servletContext.getRealPath(&quot;/&quot;)</code>相比其他中间件获取到的路径会少一个<code>/</code>，导致某些资源访问可能存在问题。</p></li></ul><a id="more"></a><ul><li>出现JSP页面无法编译的报错，需加入如下依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-2.1-glassfish<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.1.B60.25.p2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>其他的网上都能查到，我靠，花这么多时间就整出这么一点东西！！！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;坑&quot;&gt;&lt;a href=&quot;#坑&quot; class=&quot;headerlink&quot; title=&quot;坑&quot;&gt;&lt;/a&gt;坑&lt;/h2&gt;&lt;p&gt;最近花好多时间在&lt;a href=&quot;https://github.com/aharin/inproctester&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inproctester&lt;/a&gt;这个项目上,暂时还是没有很大的进展，挫败感强烈。虽然进展不多，但过程中还是接触了一些网上貌似不太好查到的新东西，记录一下不枉费这段时间的心血。&lt;/p&gt;
&lt;h2 id=&quot;Jetty是什么&quot;&gt;&lt;a href=&quot;#Jetty是什么&quot; class=&quot;headerlink&quot; title=&quot;Jetty是什么&quot;&gt;&lt;/a&gt;Jetty是什么&lt;/h2&gt;&lt;p&gt;可以内嵌到应用里的中间件，作用与&lt;code&gt;tomcat&lt;/code&gt;或&lt;code&gt;jboss&lt;/code&gt;类似，优点是不需要安装，可直接通过代码内嵌进应用，然后直接和直接应用程序一样执行。&lt;/p&gt;
&lt;h2 id=&quot;配置过程中可能存在的问题&quot;&gt;&lt;a href=&quot;#配置过程中可能存在的问题&quot; class=&quot;headerlink&quot; title=&quot;配置过程中可能存在的问题&quot;&gt;&lt;/a&gt;配置过程中可能存在的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Jetty对EL表达式的支持不好，导致页面报500无法访问，主要是针对EL表达式中的三目运算符，冒号前后的选项必须空格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Jetty运行应用时，通过&lt;code&gt;servletContext.getRealPath(&amp;quot;/&amp;quot;)&lt;/code&gt;相比其他中间件获取到的路径会少一个&lt;code&gt;/&lt;/code&gt;，导致某些资源访问可能存在问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Jetty" scheme="http://yoursite.com/tags/Jetty/"/>
    
  </entry>
  
</feed>
